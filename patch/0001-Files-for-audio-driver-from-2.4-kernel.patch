From bd9da66410b02e433d07dcf54b971521bd1c189c Mon Sep 17 00:00:00 2001
From: Marek Belisko <marek.belisko@open-nandra.com>
Date: Mon, 18 May 2009 21:50:31 +0200
Subject: Files for audio driver from 2.4 kernel.
 Signed-off-by: Marek Belisko <marek.belisko@open-nandra.com>

---
 drivers/misc/omap850-audio.c | 1118 +++++++++++++++++++++++
 drivers/misc/omap850-audio.h |   69 ++
 drivers/misc/omap850-syren.c | 2000 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 3187 insertions(+), 0 deletions(-)
 create mode 100755 drivers/misc/omap850-audio.c
 create mode 100755 drivers/misc/omap850-audio.h
 create mode 100755 drivers/misc/omap850-syren.c

diff --git a/drivers/misc/omap850-audio.c b/drivers/misc/omap850-audio.c
new file mode 100755
index 0000000..e61e83b
--- /dev/null
+++ b/drivers/misc/omap850-audio.c
@@ -0,0 +1,1118 @@
+/*
+ *  linux/drivers/sound/omap730-audio.c -- audio interface for the OMAP730 chip
+ *  Author:     Jean Pihet <j-pihet@ti.com>
+ * 
+ *  From linux/drivers/sound/pxa-audio.c -- audio interface for the Cotula chip
+ *  Author:	Nicolas Pitre
+ *  Created:	Aug 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+/*
+ *
+ *   Copyright (C) 2007 E28 SH Limited,
+ *
+ *   Revision History:
+ *  		      Modification    
+ *	    Date             Description of Changes
+ *	------------      -------------------------
+ *	June 25,2007       E28 for SmartCore Platform
+ *  March 13, 2008     add timeout mechanism for sync return
+ *  
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+#include <asm/dma.h>
+
+#include "omap730-audio.h"
+
+/*
+ * Buffering mechanism
+ *
+ * Since the P2 DMA channels (linked or not) are not dynamic (i.e. the registers cannot be
+ * updated on the fly), we have to use fixed DMA addresses and parameters.
+ *
+ * So the principle for audio playback operation is:
+ * - use AUDIO_NBFRAGS_DEFAULT user buffers of fixed size AUDIO_FRAGSIZE_DEFAULT to buffer the user
+ *   data,
+ * - use one physical channel and one DMAable buffer for data transfer to the audio device (EAC).
+ *   This buffer is divided into two parts of fixed size AUDIO_FRAGSIZE_DEFAULT,
+ * - use the HALF_FRAME and FRAME interrupts to alternately copy one of the user buffers 
+ *   into the DMA buffer half that is not in use,
+ * - the buffers management is done through the read (user buffers to DMA) and write
+ *   (user space to user buffers) buffer indexes in a circular fashion.
+ *
+ * The audio record principle is comparable, only the data transfer direction changes.
+ *
+ * This principle is not ideal because we memcpy data in the irq handler, but used because:
+ * - sufficient buffering is achieved for user data, allowing good performance under
+ *   heavy system load,
+ * - the minimum amount of work is done in the irq handler: small amount of data (usually 8KB)
+ *   is memcpy'ed. This keeps the irq handling as fast as possible.
+ */
+
+#define AUDIO_NBFRAGS_DMA		2	// DMA buffer (two halves)
+#define AUDIO_NBFRAGS_USER_DEFAULT	8	// User buffers
+#define AUDIO_FRAGSIZE_DEFAULT		8192	// Fixed size
+
+#define AUDIO_SILENCE			0x00
+
+#undef DEBUG
+//#define DEBUG
+
+static spinlock_t bufindex_lock = SPIN_LOCK_UNLOCKED;
+volatile unsigned short max_dma_count = 0;
+
+void dump_regs(char *msg, int ch)
+{
+#ifdef DEBUG
+
+#define DBPRINT(name, addr)     printk("%s: %s(@0x%08x) = 0x%08x\n", __FUNCTION__, name, (__u32) addr, *((volatile __u16*) addr));
+
+	printk("***** %s: %s *****\n", __FUNCTION__, msg);
+#if 0
+	printk("******** Clock settings ********\n");
+	DBPRINT("DPLL_CTL_REG", DPLL_CTL_REG);
+	DBPRINT("ARM_SYSST", ARM_SYSST);
+	DBPRINT("ARM_CKCTL", ARM_CKCTL);
+	DBPRINT("PCC_CTRL_REG", PCC_CTRL_REG);
+	DBPRINT("ARM_RSTCT1", ARM_RSTCT1);
+	DBPRINT("ARM_RSTCT2", ARM_RSTCT2);
+	DBPRINT("ARM_IDLECT1", ARM_IDLECT1);
+	DBPRINT("ARM_IDLECT2", ARM_IDLECT2);
+	DBPRINT("ARM_IDLECT3", ARM_IDLECT3);
+	DBPRINT("M_CTL", M_CTL);
+	printk("******** Generic DMA settings ********\n");
+	DBPRINT("OMAP_DMA_GCR_REG", OMAP_DMA_GCR_REG);
+	DBPRINT("OMAP_DMA_GSCR_REG", OMAP_DMA_GSCR_REG);
+#endif
+	printk("******** DMA channel %d settings ********\n", ch);
+	DBPRINT("OMAP_DMA_CSDP_REG", OMAP_DMA_CSDP_REG(ch));
+	DBPRINT("OMAP_DMA_CCR_REG", OMAP_DMA_CCR_REG(ch));
+	DBPRINT("OMAP_DMA_CCR2_REG", OMAP_DMA_CCR2_REG(ch));
+	DBPRINT("OMAP_DMA_CICR_REG", OMAP_DMA_CICR_REG(ch));
+	DBPRINT("OMAP_DMA_CSR_REG", OMAP_DMA_CSR_REG(ch));
+	DBPRINT("OMAP_DMA_CSSA_L_REG", OMAP_DMA_CSSA_L_REG(ch));
+	DBPRINT("OMAP_DMA_CSSA_U_REG", OMAP_DMA_CSSA_U_REG(ch));
+	DBPRINT("OMAP_DMA_CDSA_L_REG", OMAP_DMA_CDSA_L_REG(ch));
+	DBPRINT("OMAP_DMA_CDSA_U_REG", OMAP_DMA_CDSA_U_REG(ch));
+	DBPRINT("OMAP_DMA_CEN_REG", OMAP_DMA_CEN_REG(ch));
+	DBPRINT("OMAP_DMA_CFN_REG", OMAP_DMA_CFN_REG(ch));
+	DBPRINT("OMAP_DMA_CLNK_CTRL_REG", OMAP_DMA_CLNK_CTRL_REG(ch));
+	DBPRINT("OMAP_DMA_LCH_CTRL_REG", OMAP_DMA_LCH_CTRL_REG(ch));
+#endif
+}
+
+
+static void start_dma(audio_stream_t *s)
+{
+	u16 temp;
+
+	/* Prepare the first DMA buffer data */
+        if (s->output) {
+		/* Copy the next user buffer to the first half of the DMA buffer */
+		/* The other buffers will be handled in the irq handler */
+		memcpy(s->dma_buf.vaddr, s->user_buf[s->dma_frag].data, s->fragsize);
+		if (++s->dma_frag >= s->nbfrags)
+			s->dma_frag = 0;
+	}
+
+	/* Start DMA channel */
+	/* omap_start_dma() from the 2.6. kernel is equivalent to 
+	 * omap_resume_dma() from the 2.4 kernel.
+	 */
+	omap_resume_dma(OMAP_DMA_REGS(s->dma_ch));
+	s->dma_running = 1;
+
+	/* Audio Global Control Register 2: start sync transfer */
+	temp = *((volatile u16 *) EAC_AGCTR);
+        if (s->output) {
+		/* DMA write operation enabled */
+		temp |= EAC_AGCTR_DMAREN;
+        }
+        else {
+		/* DMA read operation enabled */
+		temp |= EAC_AGCTR_DMAWEN;
+	}
+	*((volatile u16 *) EAC_AGCTR) = temp;
+}
+
+static void stop_dma(audio_stream_t *s)
+{
+	u16 temp;
+
+
+	s->dma_running = 0;
+
+	/* Audio Global Control Register 2: stop sync transfer */
+	temp = *((volatile u16 *) EAC_AGCTR);
+        if (s->output) {
+		/* DMA write operation disabled */
+		temp &= ~EAC_AGCTR_DMAREN;
+        }
+        else {
+		/* DMA read operation disabled */
+		temp &= ~EAC_AGCTR_DMAWEN;
+	}
+	*((volatile u16 *) EAC_AGCTR) = temp;
+
+	/* Stop DMA channel */
+	omap_stop_dma(OMAP_DMA_REGS(s->dma_ch));
+}
+
+	  
+void audio_configure_dma_channel(audio_stream_t *s)
+{
+        dma_channel_params params;
+
+
+	// Configure the DMA channel
+        params.data_type = OMAP_DMA_DATA_TYPE_S16; 		/* data type 16 */
+        params.elem_count = s->fragsize;			/* two buffers, 16 bits of s->fragsize */
+        params.frame_count = 1;					/* only one frame */
+
+        params.src_packing = OMAP_DMA_PACK_NO;
+        params.src_burst = OMAP_DMA_BURST_NO;
+
+        params.dest_packing = OMAP_DMA_PACK_NO;
+        params.dest_burst = OMAP_DMA_BURST_NO;
+
+        //params.frame_sync = OMAP_DMA_SYNC_FRAME;
+        params.frame_sync = OMAP_DMA_SYNC_ELEMENT;
+        params.priority = OMAP_DMA_PRIO_HIGH;
+        params.auto_init = 1; 					/* auto_init at end of transfer */
+        params.repeat = 1;         				/* rept operation */
+        params.end_prog = 0;  					/* reinit itself */
+        params.omap31_comp_disable = 1; 			/* OMAP3.2 or 3.0/3.1 compatible mode */
+
+        if (s->output) {
+        	params.sync = eEACPlay;
+        	params.src_start = s->dma_buf.dma_addr;
+        	params.dest_start = EAC_ADRDR;
+        	params.src_port = OMAP_DMA_PORT_EMIFF;
+        	params.dest_port = OMAP_DMA_PORT_TIPB;
+        	params.src_amode = OMAP_DMA_AMODE_POST_INC;
+        	params.dest_amode = OMAP_DMA_AMODE_CONSTANT;
+        }
+        else {
+        	params.sync = eEACRec;
+        	params.src_start = EAC_ADWDR;
+        	params.dest_start = s->dma_buf.dma_addr;
+        	params.src_port = OMAP_DMA_PORT_TIPB;
+        	params.dest_port = OMAP_DMA_PORT_EMIFF;
+        	params.src_amode = OMAP_DMA_AMODE_CONSTANT;
+        	params.dest_amode = OMAP_DMA_AMODE_POST_INC;
+        }
+
+		params.ie = OMAP_DMA_TOUT_IRQ | OMAP_DMA_DROP_IRQ | OMAP_DMA_BLOCK_IRQ | OMAP_DMA_HALF_IRQ | OMAP_DMA_FRAME_IRQ;
+
+        omap_set_dma_params(s->dma_ch, params);
+
+	dump_regs(__FUNCTION__, s->dma_ch);
+}
+
+
+/*
+ * This function frees all buffers
+ */
+#define audio_clear_buf omap_audio_clear_buf
+
+void omap_audio_clear_buf(audio_stream_t * s)
+{
+	int frag;
+
+	if (!s->user_buf)
+		return;
+
+	/* Ensure DMA isn't running */
+	stop_dma(s);
+
+	/* free user buffers */
+	for (frag = 0; frag < s->nbfrags; frag++) {
+		audio_user_buf_t *b = &s->user_buf[frag];
+		if (b->data)
+			kfree(b->data);
+	}
+	
+	/* free DMA buffer */
+	if (s->dma_buf.vaddr)
+		consistent_free(s->dma_buf.vaddr, s->fragsize * AUDIO_NBFRAGS_DMA, s->dma_buf.dma_addr);
+
+	/* free buffer structure array */
+	kfree(s->user_buf);
+	s->user_buf = NULL;
+}
+
+/*
+ * This function allocates the DMA buffer and user buffers
+ * according to the current number of fragments and fragment size.
+ */
+static int audio_setup_buf(audio_stream_t * s)
+{
+	int frag;
+	char *dma_buf = NULL;
+	dma_addr_t dma_buf_phys = 0;
+
+	if (s->user_buf)
+		return -EBUSY;
+
+	/* Our buffer structure array */
+	s->user_buf = kmalloc(sizeof(audio_user_buf_t) * s->nbfrags, GFP_KERNEL);
+	if (!s->user_buf)
+	{
+		goto err;
+	}
+	memzero(s->user_buf, sizeof(audio_user_buf_t) * s->nbfrags);
+
+	/* Our user buffers */
+	for (frag = 0; frag < s->nbfrags; frag++) {
+		audio_user_buf_t *b = &s->user_buf[frag];
+		b->data = kmalloc(s->fragsize, GFP_KERNEL);
+		if (!b->data)
+		{
+			goto err;
+		}
+		memzero(b->data, s->fragsize);
+
+		/* handle buffer pointers */
+		b->offset = 0;
+	}
+
+	/* Our actual DMA buffer
+	 * Let's allocate non-cached memory for DMA buffers.
+	 */
+	dma_buf = consistent_alloc(GFP_KERNEL | GFP_DMA | GFP_ATOMIC, s->fragsize * AUDIO_NBFRAGS_DMA, &dma_buf_phys);
+	if (!dma_buf)
+	{
+		goto err;
+	}
+	memzero(dma_buf, s->fragsize * AUDIO_NBFRAGS_DMA);
+	s->dma_buf.vaddr = dma_buf;
+	s->dma_buf.dma_addr = dma_buf_phys;
+
+	// Reconfigure the DMA to reflect the DMA physical address and buffer size
+	audio_configure_dma_channel(s);
+
+#if 0	// Debug
+	printk("%s: s=0x%08x\n", __FUNCTION__, s);
+	printk("%s: s->user_buf=0x%08x, s->dma_buf.vaddr=0x%08x, s->dma_buf.dma_addr=0x%08x, s->fragsize=0x%08x\n",__FUNCTION__, s->user_buf, s->dma_buf.vaddr, s->dma_buf.dma_addr, s->fragsize);
+
+	for (frag = 0; frag < s->nbfrags; frag++) {
+		printk("%s: s->user_buf[%d].data=0x%08x\n", __FUNCTION__, frag, s->user_buf[frag].data);
+	}
+#endif
+
+	/* Init stream struct */
+	s->usr_frag = s->dma_frag = 0;
+	s->dma_running = 0;
+	s->bytecount = 0;
+	s->fragcount = 0;
+	sema_init(&s->sem, (s->output) ? s->nbfrags-1 : 0);
+	return 0;
+
+err:
+	printk("omap-audio: unable to allocate audio memory\n ");
+	audio_clear_buf(s);
+	return -ENOMEM;
+}
+
+/*
+ * Our DMA interrupt handler
+ */
+static void audio_dma_irq(void *stream)
+{
+	audio_stream_t *s = stream;
+	int ch;
+	u16 ch_status;
+
+	ch = s->dma_ch;
+	ch_status = omap_dma_get_status(OMAP_DMA_REGS(ch));
+
+	if (!s->user_buf) {
+		printk("OMAP730 AUDIO DMA: wow... received IRQ for channel %d but no buffer exists\n", ch);
+		return;
+	}
+
+	// Process the half frame interrupt:
+	//  now the first half of the buffer is not in use by the DMA anymore
+	if (ch_status & OMAP_DMA_HALF_IRQ)
+	{
+		if (s->output)
+		{
+			// Check if we have free buffers
+			if (USER_BUF_IS_EMPTY(s))
+			{
+				stop_dma(s);
+			} else
+			{
+				// Copy the next user buffer to the first half of the DMA buffer
+				memcpy(s->dma_buf.vaddr, s->user_buf[s->dma_frag].data, s->fragsize);
+
+				if (++s->dma_frag >= s->nbfrags)
+					s->dma_frag = 0;
+			}
+		} else
+		{
+			// Check if we have free buffers
+			if (!USER_BUF_READ_HAS_PLACE(s))
+			{
+				stop_dma(s);
+			} else
+			{
+				// Copy the first half of the DMA buffer to the next user buffer
+				memcpy(s->user_buf[s->dma_frag].data, s->dma_buf.vaddr, s->fragsize);
+
+				if (++s->dma_frag >= s->nbfrags)
+					s->dma_frag = 0;
+			}
+		}
+
+		// Wake-up waiting processes
+		if (!s->mapped)
+			up(&s->sem);
+
+		/* Accounting */
+		s->bytecount += s->fragsize;
+		s->fragcount++;
+
+		/* ... and for polling processes */
+		wake_up(&s->frag_wq);
+	}
+
+	// Process the end of frame interrupt:
+	//  now the second half of the buffer is not in use by the DMA anymore
+	if (ch_status & OMAP_DMA_FRAME_IRQ)
+	{
+		if (s->output)
+		{
+			// Check if we have free buffers
+			if (USER_BUF_IS_EMPTY(s))
+			{
+				stop_dma(s);
+			} else
+			{
+				// Copy the next user buffer to the second half of the DMA buffer
+				memcpy(s->dma_buf.vaddr + s->fragsize, s->user_buf[s->dma_frag].data, s->fragsize);
+
+				if (++s->dma_frag >= s->nbfrags)
+					s->dma_frag = 0;
+			}
+		} else
+		{
+			if (!USER_BUF_READ_HAS_PLACE(s))
+			{
+				stop_dma(s);
+			} else
+			{
+				// Copy the first half of the DMA buffer to the next user buffer
+				// Copy the second half of the DMA buffer to the next user buffer
+				memcpy(s->user_buf[s->dma_frag].data, s->dma_buf.vaddr + s->fragsize, s->fragsize);
+
+				if (++s->dma_frag >= s->nbfrags)
+					s->dma_frag = 0;
+			}
+		}
+
+		// Wake-up waiting processes
+		if (!s->mapped)
+			up(&s->sem);
+
+		/* Accounting */
+		s->bytecount += s->fragsize;
+		s->fragcount++;
+
+		/* ... and for polling processes */
+		wake_up(&s->frag_wq);
+	}
+}
+
+/*
+ * Validate and sets up buffer fragments, etc.
+ */
+static int audio_set_fragments(audio_stream_t *s, int val)
+{
+	if (s->mapped || s->dma_running)
+		return -EBUSY;
+	if (s->user_buf)
+		audio_clear_buf(s);
+	s->nbfrags = (val >> 16) & 0x7FFF;
+	val &= 0xffff;
+	if (val < 5)
+		val = 5;
+	if (val > 15)
+		val = 15;
+	s->fragsize = 1 << val;
+	if (s->nbfrags < 2)
+		s->nbfrags = 2;
+	if (s->nbfrags * s->fragsize > 256 * 1024)
+		s->nbfrags = 256 * 1024 / s->fragsize;
+	if (audio_setup_buf(s))
+		return -ENOMEM;
+	return val|(s->nbfrags << 16);
+}
+
+
+/*
+ * The fops functions
+ */
+
+static int audio_write(struct file *file, const char *buffer,
+		       size_t count, loff_t * ppos)
+{
+	const char *buffer0 = buffer;
+	audio_state_t *state = (audio_state_t *)file->private_data;
+	audio_stream_t *s = state->output_stream;
+	int chunksize, ret = 0;
+        unsigned long flags;
+
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+	if (s->mapped)
+		return -ENXIO;
+	if (!s->user_buf && audio_setup_buf(s))
+		return -ENOMEM;
+
+	while (count > 0) {
+		audio_user_buf_t *b = &s->user_buf[s->usr_frag];
+
+		/* Grab a fragment */
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			if (down_trylock(&s->sem))
+				break;
+		} else {
+			ret = -ERESTARTSYS;
+			if (down_interruptible(&s->sem))
+				break;
+		}
+		/* Feed the current buffer */
+		chunksize = s->fragsize - b->offset;
+		if (chunksize > count)
+			chunksize = count;
+		if (copy_from_user(b->data + b->offset, buffer, chunksize)) {
+			up(&s->sem);
+			return -EFAULT;
+		}
+		b->offset += chunksize;
+		buffer += chunksize;
+		count -= chunksize;
+		if (b->offset < s->fragsize) {
+			up(&s->sem);
+			break;
+		}
+
+		spin_lock_irqsave(&bufindex_lock, flags);
+		/* move the index to the next fragment */
+		if (++s->usr_frag >= s->nbfrags)
+			s->usr_frag = 0;
+		spin_unlock_irqrestore(&bufindex_lock, flags);
+
+		/* 
+		 * Activate DMA on current buffer.
+		 */
+		b->offset = 0;
+		if (!s->dma_running) {
+			start_dma(s);
+		}
+	}
+
+	if ((buffer - buffer0))
+		ret = buffer - buffer0;
+	return ret;
+}
+
+
+static int audio_read(struct file *file, char *buffer,
+		      size_t count, loff_t * ppos)
+{
+	char *buffer0 = buffer;
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->input_stream;
+	int chunksize, ret = 0;
+        unsigned long flags;
+
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+	if (s->mapped)
+		return -ENXIO;
+	if (!s->user_buf && audio_setup_buf(s))
+		return -ENOMEM;
+
+	while (count > 0) {
+		audio_user_buf_t *b = &s->user_buf[s->usr_frag];
+
+		/* prime DMA */
+		if (!s->dma_running) {
+			start_dma(s);
+		}
+
+		/* Wait for a buffer to become full */
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			if (down_trylock(&s->sem))
+				break;
+		} else {
+			ret = -ERESTARTSYS;
+			if (down_interruptible(&s->sem))
+				break;
+		}
+
+		/* Grab data from current buffer */
+		chunksize = s->fragsize - b->offset;
+		if (chunksize > count)
+			chunksize = count;
+		if (copy_to_user(buffer, b->data + b->offset, chunksize)) {
+			up(&s->sem);
+			return -EFAULT;
+		}
+		b->offset += chunksize;
+		buffer += chunksize;
+		count -= chunksize;
+		if (b->offset < s->fragsize) {
+			up(&s->sem);
+			break;
+		}
+
+		/* 
+		 * Make this buffer available for DMA again.
+		 */
+		b->offset = 0;
+
+		/* move the index to the next fragment */
+		spin_lock_irqsave(&bufindex_lock, flags);
+		if (++s->usr_frag >= s->nbfrags)
+			s->usr_frag = 0;
+		spin_unlock_irqrestore(&bufindex_lock, flags);
+	}
+
+	if ((buffer - buffer0))
+		ret = buffer - buffer0;
+	return ret;
+}
+
+
+static int audio_sync(struct file *file)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->output_stream;
+	audio_user_buf_t *b;
+	DECLARE_WAITQUEUE(wait, current);
+	int pad_size;
+        unsigned long flags;
+
+
+	if (!(file->f_mode & FMODE_WRITE) || !s->user_buf || s->mapped)
+		return 0;
+
+	/*
+	 * Send current buffer if it contains data.  Be sure to send
+	 * a full sample count. As we have to work with fixed size
+	 * buffers, just pad ... Ark too bad !
+	 *
+	 * Note that this is bad for really short samples (beep beep).
+	 */
+	b = &s->user_buf[s->usr_frag];
+	pad_size = s->fragsize - b->offset;
+
+	if (pad_size <= 0)
+		return 0;
+
+	memset(b->data + b->offset, AUDIO_SILENCE, pad_size);
+
+	spin_lock_irqsave(&bufindex_lock, flags);
+	/* move the index to the next fragment */
+	if (++s->usr_frag >= s->nbfrags)
+		s->usr_frag = 0;
+	spin_unlock_irqrestore(&bufindex_lock, flags);
+
+	if (!s->dma_running) {
+		start_dma(s);
+	}
+
+	/* Wait for DMA to complete. */
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&s->frag_wq, &wait);
+	max_dma_count = s->nbfrags;
+	while (s->dma_running && !signal_pending(current) && (max_dma_count--)) {
+		schedule_timeout(10);
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&s->frag_wq, &wait);
+
+	return 0;
+}
+
+
+static unsigned int audio_poll(struct file *file,
+			       struct poll_table_struct *wait)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *is = state->input_stream;
+	audio_stream_t *os = state->output_stream;
+	unsigned int mask = 0;
+
+	if (file->f_mode & FMODE_READ) {
+		/* Start audio input if not already active */
+		if (!is->user_buf && audio_setup_buf(is))
+			return -ENOMEM;
+		if (!is->dma_running) {
+			start_dma(is);
+		}
+		poll_wait(file, &is->frag_wq, wait);
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!os->user_buf && audio_setup_buf(os))
+			return -ENOMEM;
+		poll_wait(file, &os->frag_wq, wait);
+	}
+
+	if (file->f_mode & FMODE_READ)
+		if (( is->mapped && is->bytecount > 0) ||
+		    (!is->mapped && atomic_read(&is->sem.count) > 0))
+			mask |= POLLIN | POLLRDNORM;
+
+	if (file->f_mode & FMODE_WRITE)
+		if (( os->mapped && os->bytecount > 0) ||
+		    (!os->mapped && atomic_read(&os->sem.count) > 0))
+			mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+
+
+static int audio_ioctl( struct inode *inode, struct file *file,
+			uint cmd, ulong arg)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	long val;
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(os->fragsize, (int *)arg);
+		else
+			return put_user(is->fragsize, (int *)arg);
+
+	case SNDCTL_DSP_GETCAPS:
+		val = DSP_CAP_REALTIME|DSP_CAP_TRIGGER|DSP_CAP_MMAP;
+		if (is && os)
+			val |= DSP_CAP_DUPLEX;
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (long *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			int ret = audio_set_fragments(is, val);
+			if (ret < 0)
+				return ret;
+			ret = put_user(ret, (int *)arg);
+			if (ret)
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			int ret = audio_set_fragments(os, val);
+			if (ret < 0)
+				return ret;
+			ret = put_user(ret, (int *)arg);
+			if (ret)
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SYNC:
+		return audio_sync(file);
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		if (file->f_mode & FMODE_READ && !USER_BUF_IS_EMPTY(is))
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && !USER_BUF_IS_EMPTY(os))
+			val |= PCM_ENABLE_OUTPUT;
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT) {
+				if (!is->user_buf && audio_setup_buf(is))
+					return -ENOMEM;
+				if (!is->dma_running)
+					start_dma(is);
+			} else {
+				stop_dma(is);
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT) {
+				if (!os->user_buf && audio_setup_buf(os))
+					return -ENOMEM;
+				if (!os->dma_running)
+					start_dma(os);
+			} else {
+				stop_dma(os);
+			}
+		}
+		return 0;
+
+	case SNDCTL_DSP_GETOSPACE:
+	case SNDCTL_DSP_GETISPACE:
+	    {
+		audio_buf_info inf = { 0, };
+		audio_stream_t *s = (cmd == SNDCTL_DSP_GETOSPACE) ? os : is;
+
+		if ((s == is && !(file->f_mode & FMODE_READ)) ||
+		    (s == os && !(file->f_mode & FMODE_WRITE)))
+			return -EINVAL;
+		if (!s->user_buf && audio_setup_buf(s))
+			return -ENOMEM;
+		inf.bytes = atomic_read(&s->sem.count) * s->fragsize;
+		inf.bytes -= s->user_buf[s->usr_frag].offset;
+		inf.fragments = inf.bytes / s->fragsize;
+		inf.fragsize = s->fragsize;
+		inf.fragstotal = s->nbfrags;
+		return copy_to_user((void *)arg, &inf, sizeof(inf));
+	    }
+
+	case SNDCTL_DSP_GETOPTR:
+	case SNDCTL_DSP_GETIPTR:
+	    {
+		count_info inf = { 0, };
+		audio_stream_t *s = (cmd == SNDCTL_DSP_GETOPTR) ? os : is;
+		dma_addr_t ptr;
+		int bytecount, offset, flags;
+
+		if ((s == is && !(file->f_mode & FMODE_READ)) ||
+		    (s == os && !(file->f_mode & FMODE_WRITE)))
+			return -EINVAL;
+		if (s->dma_running) {
+			save_flags_cli(flags);
+			ptr = (s->output) ? OMAP_DMA_CDAC_REG(s->dma_ch) : OMAP_DMA_CSAC_REG(s->dma_ch);
+			offset = ptr - s->dma_buf.dma_addr;
+			if (offset >= s->fragsize)
+				offset = s->fragsize - 4;
+		} else {
+			save_flags(flags);
+			offset = 0;
+		}
+		inf.ptr = s->dma_frag * s->fragsize + offset;
+		bytecount = s->bytecount + offset;
+		s->bytecount = -offset;
+		inf.blocks = s->fragcount;
+		s->fragcount = 0;
+		restore_flags(flags);
+		if (bytecount < 0)
+			bytecount = 0;
+		inf.bytes = bytecount;
+		return copy_to_user((void *)arg, &inf, sizeof(inf));
+	    }
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_WRITE) 
+			audio_clear_buf(os);
+		if (file->f_mode & FMODE_READ)
+			audio_clear_buf(is);
+		return 0;
+
+	default:
+		return state->client_ioctl(inode, file, cmd, arg);
+	}
+
+	return 0;
+}
+
+
+static int audio_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s;
+	unsigned long size, vma_addr;
+	int i, ret;
+
+	if (vma->vm_pgoff != 0)
+		return -EINVAL;
+
+	if (vma->vm_flags & VM_WRITE) {
+		if (!state->wr_ref)
+			return -EINVAL;;
+		s = state->output_stream;
+	} else if (vma->vm_flags & VM_READ) {
+		if (!state->rd_ref)
+			return -EINVAL;
+		s = state->input_stream;
+	} else return -EINVAL;
+
+	if (s->mapped)
+		return -EINVAL;
+	size = vma->vm_end - vma->vm_start;
+	if (size != s->fragsize * s->nbfrags)
+		return -EINVAL;
+	if (!s->user_buf && audio_setup_buf(s))
+		return -ENOMEM;
+	vma_addr = vma->vm_start;
+	for (i = 0; i < s->nbfrags; i++) {
+		audio_user_buf_t *buf = &s->user_buf[i];
+		if (!buf->data)
+			continue;
+		ret = remap_page_range(vma_addr, s->dma_buf.dma_addr,
+				       s->fragsize * AUDIO_NBFRAGS_DMA, vma->vm_page_prot);
+		if (ret)
+			return ret;
+		vma_addr += s->fragsize * AUDIO_NBFRAGS_DMA;
+	}
+	// Start DMA here ???
+	//for (i = 0; i < s->nbfrags; i++)
+	//	s->user_buf[i].dma_desc->ddadr &= ~DDADR_STOP;
+	s->mapped = 1;
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int audio_pm_callback(struct pm_dev *pm_dev, pm_request_t req, void
+*data)
+{
+#if 0
+        audio_state_t *state = pm_dev->data;
+        audio_stream_t *is = state->input_stream;
+        audio_stream_t *os = state->output_stream;
+
+        FN_IN;
+        switch (req) {
+        case PM_SUSPEND: /* enter D1-D3 */
+                if (is) {
+			stop_dma(is);
+                }
+                if (os) {
+			stop_dma(os);
+                }
+                if (state->hw_shutdown)
+                        state->hw_shutdown(state);
+                break;
+        case PM_RESUME:  /* enter D0 */
+                if (state->hw_init)
+                        state->hw_init(state);
+                if (os) {
+			start_dma(os);
+                }
+                if (is) {
+			start_dma(is);
+                }
+                break;
+        }
+        FN_OUT(0);
+#endif
+        return 0;
+}
+
+#endif
+/* Power Management Functions for Linux Device Model  */
+
+void audio_ldm_suspend(void *data)
+{
+#if 0
+        audio_state_t *state = data;
+        audio_stream_t *is = state->input_stream;
+        audio_stream_t *os = state->output_stream;
+
+        if (is)
+        {
+		stop_dma(is);
+        }
+        if (os)
+        {
+		stop_dma(os);
+        }
+        if (state->hw_shutdown)
+                state->hw_shutdown(state);
+#endif
+}
+
+void audio_ldm_resume(void *data)
+{
+#if 0
+        audio_state_t *state = data;
+        audio_stream_t *is = state->input_stream;
+        audio_stream_t *os = state->output_stream;
+
+        if (state->hw_init)
+                state->hw_init(state);
+
+        if (os)
+        { 
+		start_dma(os);
+        }
+        if (is)
+        {
+		start_dma(is);
+        }
+#endif
+}
+
+static int audio_release(struct inode *inode, struct file *file)
+{
+	audio_state_t *state = file->private_data;
+
+	down(&state->sem);
+
+	if (file->f_mode & FMODE_READ) {
+		stop_dma(state->input_stream);
+		audio_clear_buf(state->input_stream);
+		omap_free_dma(OMAP_DMA_REGS(state->input_stream->dma_ch));
+		state->rd_ref = 0;
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		//audio_sync(file);
+		audio_clear_buf(state->output_stream);
+		omap_free_dma(OMAP_DMA_REGS(state->output_stream->dma_ch));
+		state->wr_ref = 0;
+	}
+
+	if ((state->rd_ref == 0) && (state->wr_ref == 0))
+	{
+		if (state->hw_shutdown)
+			state->hw_shutdown(state);
+#ifdef CONFIG_PM
+		pm_unregister(state->pm_dev);
+#endif
+	}
+
+	up(&state->sem);
+	return 0;
+}
+
+int omap_audio_attach(struct inode *inode, struct file *file,
+			 audio_state_t *state)
+{
+	audio_stream_t *is = state->input_stream;
+	audio_stream_t *os = state->output_stream;
+	int dma_ch;
+	int err;
+	dma_regs_t *dma_regs;
+	
+
+	down(&state->sem);
+
+	/* access control */
+	err = -ENODEV;
+	if ((file->f_mode & FMODE_WRITE) && !os)
+		goto out;
+	if ((file->f_mode & FMODE_READ) && !is)
+		goto out;
+	err = -EBUSY;
+	if ((file->f_mode & FMODE_WRITE) && (state->wr_ref || state->rd_ref))
+		goto out;
+	if ((file->f_mode & FMODE_READ) && (state->rd_ref || state->wr_ref))
+		goto out;
+
+	/* request DMA channel */
+	if (file->f_mode & FMODE_WRITE) {
+        	err = omap_request_dma(eEACPlay, "Audio TX DMA", audio_dma_irq, 
+			os, &dma_regs);
+		dma_ch = OMAP_DMA_CH(dma_regs);
+		if (err < 0)
+			goto out;
+		os->dma_ch = dma_ch;
+	}
+	if (file->f_mode & FMODE_READ) {
+        	err = omap_request_dma(eEACRec, "Audio RX DMA", audio_dma_irq, 
+			is, &dma_regs);
+		dma_ch = OMAP_DMA_CH(dma_regs);
+		if (err < 0) {
+			if (file->f_mode & FMODE_WRITE) {
+				omap_free_dma(OMAP_DMA_REGS(os->dma_ch));
+			}
+			goto out;
+		}
+		is->dma_ch = dma_ch;
+	}
+
+	file->private_data	= state;
+	file->f_op->release	= audio_release;
+	file->f_op->write	= audio_write;
+	file->f_op->read	= audio_read;
+	file->f_op->mmap	= audio_mmap;
+	file->f_op->poll	= audio_poll;
+	file->f_op->ioctl	= audio_ioctl;
+	file->f_op->llseek	= no_llseek;
+
+	if ((file->f_mode & FMODE_WRITE)) {
+		state->wr_ref = 1;
+		os->fragsize = AUDIO_FRAGSIZE_DEFAULT;
+		os->nbfrags = AUDIO_NBFRAGS_USER_DEFAULT;
+		os->output = 1;
+		os->mapped = 0;
+		init_waitqueue_head(&os->frag_wq);
+	}
+	if (file->f_mode & FMODE_READ) {
+		state->rd_ref = 1;
+		is->fragsize = AUDIO_FRAGSIZE_DEFAULT;
+		is->nbfrags = AUDIO_NBFRAGS_USER_DEFAULT;
+		is->output = 0;
+		is->mapped = 0;
+		init_waitqueue_head(&is->frag_wq);
+	}
+
+	if ((!(file->f_mode & FMODE_WRITE)) && (!(file->f_mode & FMODE_READ))) {
+		err = -ENODEV;
+		goto out;
+        }
+
+	if (state->hw_init)
+		state->hw_init(state);
+#ifdef CONFIG_PM
+	state->pm_dev = pm_register(PM_SYS_DEV, 0, audio_pm_callback);
+	if (state->pm_dev)
+		state->pm_dev->data = state;
+#endif
+
+	err = 0;
+
+out:
+	up(&state->sem);
+	return err;
+}
+
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(omap_audio_attach);
+EXPORT_SYMBOL(omap_audio_clear_buf);
+EXPORT_SYMBOL(audio_ldm_resume);
+EXPORT_SYMBOL(audio_ldm_suspend);
diff --git a/drivers/misc/omap850-audio.h b/drivers/misc/omap850-audio.h
new file mode 100755
index 0000000..52298f7
--- /dev/null
+++ b/drivers/misc/omap850-audio.h
@@ -0,0 +1,69 @@
+/*
+ *  linux/drivers/sound/omap730-audio.h -- audio interface for the OMAP730 chip
+ *  Author: Jean Pihet <j-pihet@ti.com>
+ *
+ *  From linux/drivers/sound/pxa-audio.h
+ *  Author:	Nicolas Pitre
+ *  Created:	Aug 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+// User buffers struct
+typedef struct {
+	int offset;			/* current buffer position in the buffer */
+	char *data; 	           	/* actual buffer */
+} audio_user_buf_t;
+
+// DMA buffer struct
+typedef struct {
+	char *vaddr;			/* DMA virtual address */
+	dma_addr_t dma_addr;		/* DMA physical address */
+} audio_dma_buf_t;
+
+typedef struct {
+	char *name;			/* stream identifier */
+	audio_user_buf_t *user_buf;   	/* pointer to user audio buffers array */
+	audio_dma_buf_t dma_buf;	/* DMA buffer info */
+	u_int usr_frag;			/* user fragment index */
+	u_int dma_frag;			/* DMA fragment index */
+	u_int fragsize;			/* fragment size */
+	u_int nbfrags;			/* number of fragments */
+	u_int dma_ch;			/* DMA channel number */
+	int bytecount;			/* nbr of processed bytes */
+	int fragcount;			/* nbr of fragment transitions */
+	struct semaphore sem;		/* account for fragment usage */
+	wait_queue_head_t frag_wq;	/* for poll(), etc. */
+	int mapped:1;			/* mmap()'ed buffers */
+	int output:1;			/* 0 for input, 1 for output */
+	int dma_running:1;		/* 0 if stopped, 1 if running */
+} audio_stream_t;
+	
+typedef struct {
+	audio_stream_t *output_stream;
+	audio_stream_t *input_stream;
+	int dev_dsp;			/* audio device handle */
+	int rd_ref:1;           /* open reference for recording */
+	int wr_ref:1;           /* open reference for playback */
+	void (*hw_init)(void *);
+	void (*hw_shutdown)(void *);
+	int (*client_ioctl)(struct inode *, struct file *, uint, ulong);
+	struct semaphore sem;		/* prevent races in attach/release */
+} audio_state_t;
+
+extern int omap_audio_attach(struct inode *inode, struct file *file,
+				audio_state_t *state);
+extern void omap_audio_clear_buf(audio_stream_t *s);
+
+
+/* User buffers mgt macros */
+
+// Has place: at least one buffer is free to use
+#define USER_BUF_READ_HAS_PLACE(s)	( !(((s->dma_frag + 1) % s->nbfrags) == s->usr_frag) )
+
+// Is empty: all the buffers are free to use
+#define USER_BUF_IS_EMPTY(s)		( s->dma_frag == s->usr_frag )
+
diff --git a/drivers/misc/omap850-syren.c b/drivers/misc/omap850-syren.c
new file mode 100755
index 0000000..0a1bc75
--- /dev/null
+++ b/drivers/misc/omap850-syren.c
@@ -0,0 +1,2000 @@
+/*
+ *
+ * Glue audio driver for the TI OMAP730 & TI TWL3016 (Syren) CODEC
+ *          (based on omap1610-tsc2101.c)
+ * Jean Pihet <j-pihet@ti.com>
+ *
+ * Copyright 2003 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *	   source@mvista.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/*
+ *
+ *   Copyright (C) 2007, 2008 E28 SH Limited,
+ *
+ *   Revision History:
+ *  		      Modification    
+ *	    Date             Description of Changes
+ *	------------      -------------------------
+ *	June 25,2007       E28 for SmartCore Platform
+ *  March 23, 2008     Change for VRIO power saving.
+ * Jul 28, 2008        Bypass EAC when EAC's clock is shut down
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/input.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/ck.h>
+
+#include "omap730-audio.h"
+#ifdef MODULE	
+#include "../gsm/csmi.h"
+#else
+#include "../gsm/csmi.h"
+#endif
+#include <asm/irq.h>
+#include <asm/arch/irq.h>
+
+#if defined(CONFIG_ARCH_OMAP730)
+#include <asm/arch/omap730_config.h>
+#include <asm/arch/perseus2.h>
+#endif
+//#undef CONFIG_CEE
+#define CONFIG_CEE
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define DPRINTK( x... )  printk(KERN_WARNING x)
+//#define DPRINTK( x... )  printk( ##x )
+#define FN_IN printk("%s start\n", __FUNCTION__)
+#define FN_OUT(n) printk("%s end(%d)\n", __FUNCTION__, n)
+#else
+#define DPRINTK( x... )
+#define FN_IN
+#define FN_OUT(n)
+#endif
+
+#define AUDIO_NAME		"OMAP730_SYREN"
+
+#define AUDIO_RATE_DEFAULT	44100
+
+#define REC_MASK ( SOUND_MASK_LINE | SOUND_MASK_MIC )
+#define DEV_MASK ( REC_MASK | SOUND_MASK_PCM )
+
+#define SET_LINE   1
+#define SET_PCM    2
+
+#define DEFAULT_VOLUME       	100 //100 // 100 0x7f 81	// 0 dB gain
+#define DEFAULT_INPUT_VOLUME 	0	// mute inputs
+
+#define OUTPUT_VOLUME_MIN 	0x00
+#define OUTPUT_VOLUME_MAX 	0x7F
+#define OUTPUT_VOLUME_RANGE 	(OUTPUT_VOLUME_MAX - OUTPUT_VOLUME_MIN)
+#define OUTPUT_VOLUME_MASK 	OUTPUT_VOLUME_MIN
+
+#define INPUT_VOLUME_MIN 	0x00
+#define INPUT_VOLUME_MAX 	0x7F
+#define INPUT_VOLUME_RANGE 	(INPUT_VOLUME_MAX - INPUT_VOLUME_MIN)
+#define INPUT_VOLUME_MASK 	INPUT_VOLUME_MAX
+
+#define	DMA_DEFAULT_VOLUME	0xFF		// // Max Vol: 0xFF +12db	Min Vol:0xE7 0dB
+#define	MIXER_DEFAULT_VOLUME	0x67	// 0dB gain
+
+#define EARPHONE_JACK_HARDKEY	(252 << 16)
+#define SNDCTL_DSP_AUDIOVOICE				0x2242
+#define SNDCTL_DSP_VOICEBANDCTL				0x2243
+#define SNDCTL_DSP_OUTPUTCTL				0x2244
+#define SNDCTL_DSP_SIDETONE				0x2245
+#define SNDCTL_DSP_AUDIOCODEC				0x2246
+#define SNDCTL_DSP_ECHOCANC				0x2247
+#define SNDCTL_DSP_AUDIOPGA				0x2248
+#define SNDCTL_DSP_AUDIOBT				0x2249
+#define SNDCTL_DSP_DUMP_REG				0x2250
+#define SNDCTL_DSP_ENHECHOCANC				0x2251
+#define SNDCTL_DSP_AUDIOPROFILE				0x2252
+#define SNDCTL_DSP_ABB_READ				0x2260
+#define SNDCTL_DSP_ABB_WRITE				0x2261
+#define SNDCTL_DSP_BTCTRL				0x2270
+#define SNDCTL_DSP_BYPASSCTRL				0x2271
+#define SNDCTL_DSP_CHGSWITCH				0x2280
+#define SNDCTL_DSP_SYREN_READ				0x2281
+#define GPIO_NEW_SETUP					0x1242
+#define GPIO_GET_OUTPUT					0x1243
+#define GPIO_GET_INPUT					0x1244
+
+typedef struct {
+	unsigned long pin;	// pin num	
+	unsigned long pin_dir;	// direction
+	unsigned long pin_def;	//default
+} gpio_para;
+
+// Structure format for the GC AUDIO VOICE BAND CONTROL request
+typedef struct
+{
+    u16    vbctl1;
+    u16	   vbctl2;
+} audio_voicebandctl;
+
+// Structure format for the GC AUDIO VOICE request
+typedef struct
+{
+    //u8     Uplink;
+    u8     Mute;
+    //u8     Volume;
+} audio_voice;
+
+typedef struct
+{
+    u8     Uplink;
+    u8     Gain;
+} audio_pga;
+
+// Structure format for the GC Stereo Codec request
+typedef struct
+{
+    u8     on_off;
+    u8     AudioMode;
+    u8     Gain;
+    u8     SampleFrequency;
+} audio_codec;
+
+typedef struct
+{
+    u16     Flag;
+    u16     Para1;
+    u16     Para2;
+    u16     Para3;
+    u16     Para4;
+    u16     Para5;
+} audio_enhechocanc;
+
+typedef struct
+{
+	u16	  Page;
+	u16	  RegisterAddr;
+	u16	  Value;
+} abb_register_write;
+
+typedef struct
+{
+	u16	  Page;
+	u16	  RegisterAddr;
+} abb_register_read;
+
+/*
+  Local prototypes.
+*/
+static void omap730_audio_init(void *dummy);
+static void omap730_audio_shutdown(void *dummy);
+static int omap730_audio_ioctl(struct inode *inode, struct file *file,
+                                uint cmd, ulong arg);
+static int omap730_getclock(void);
+static void omap730_setclock(int on_off);
+
+
+#ifdef CONFIG_CEE  /* MVL-CEE */
+#include <linux/device.h>
+
+static int omap730_audio_suspend(struct device * dev, u32 state, u32 level);
+static int omap730_audio_resume(struct device * dev, u32 level);
+
+extern u32 GTI_IOControl(u32 hOpenContext, u32 dwCode, u8* pBufIn, u32 dwLenIn, u8* pBufOut, u32 dwLenOut, u32* pdwActualOut);
+static int GSM_WriteAbb(u16 Page,u16 RegisterAddr,u16 Value);
+static u16 GSM_ReadAbb(u16 Page,u16 RegisterAddr);
+static int GSM_SetupAudio( u8 on_off, u8 AudioMode,u8 Gain, u8 SampleFrequency);
+static int GTI_Audio_Echocanc(u16 Algorithm);
+static int GTI_Audio_EnhEchocanc(u16 Flag, u16 Para1, u16 Para2, u16 Para3, u16 Para4, u16 Para5);
+static int GTI_Output_CTRL(u16 vauoctl);
+static int GTI_Voiceband_Ctl(u16 vbctl1, u16 vbctl2);
+static int GTI_Audio_Voice(u8 Mute);
+static int GTI_Audio_PGA(u8 Uplink, u8 Gain);
+static int GTI_Audio_Sidetone(u8 Volume);
+static int GTI_Audio_Profileload(u8 Profile);
+static int bt_control(int on_off);
+static void modem_bypass(int on_off);
+static struct device_driver audio_driver_ldm = {
+       name:      "omap730-syren",
+       devclass:  NULL,
+       probe:     NULL,
+       suspend:   omap730_audio_suspend,
+       resume:    omap730_audio_resume,
+       remove:    NULL,
+};
+
+static struct device audio_device_ldm = {
+       name: "OMAP730/TWL3016 (SYREN) Audio Codec",
+       bus_id: "I2S_Audio",
+       driver: NULL,
+       power_state: DPM_POWER_ON,
+};
+
+static void audio_ldm_driver_register(void)
+{
+   extern void dsp_public_driver_register(struct device_driver *driver);
+   FN_IN;
+   dsp_public_driver_register(&audio_driver_ldm);
+   FN_OUT(0);
+}
+
+static void audio_ldm_device_register(void)
+{
+   extern void dsp_public_device_register(struct device *device);
+   FN_IN;
+   dsp_public_device_register(&audio_device_ldm);
+   FN_OUT(0);
+}
+
+static void audio_ldm_driver_unregister(void)
+{
+   extern void dsp_public_driver_unregister(struct device_driver *driver);
+   FN_IN;
+   dsp_public_driver_unregister(&audio_driver_ldm);
+   FN_OUT(0);
+}
+
+static void audio_ldm_device_unregister(void)
+{
+   extern void dsp_public_device_unregister(struct device *device);
+   FN_IN;
+   dsp_public_device_unregister(&audio_device_ldm);
+   FN_OUT(0);
+}
+#endif /* MVL-CEE */
+
+static u8 syren_codec_onoff;;
+static audio_stream_t output_stream = {
+		name:		"SYREN out",
+};
+
+static audio_stream_t input_stream = {
+		name:		"SYREN in",
+};
+
+static audio_state_t audio_state = {
+	output_stream:	&output_stream,
+	input_stream:	&input_stream,
+	hw_init:	omap730_audio_init,
+	hw_shutdown:	omap730_audio_shutdown,
+	client_ioctl:	omap730_audio_ioctl,
+	sem:		__MUTEX_INITIALIZER(audio_state.sem),
+};
+
+struct {
+        u8 volume;
+        u8 line;
+        u8 mic;
+        int mod_cnt;
+} eac_local;
+
+
+static void eac_dump(void)
+{
+#ifdef DEBUG
+
+	#define DBPRINT(name, addr)     printk("%s: %s(@0x%08x) = 0x%08x\n", __FUNCTION__, name, (__u32) addr, *((__u16 *) addr));
+
+	DBPRINT("DPLL1_CTL_REG", DPLL1_CTL_REG);
+	DBPRINT("ARM_SYSST", ARM_SYSST);
+	DBPRINT("ARM_CKCTL", ARM_CKCTL);
+	DBPRINT("PCC_CTRL_REG", PCC_CTRL_REG);
+	DBPRINT("ARM_RSTCT2", ARM_RSTCT2);
+	DBPRINT("ARM_IDLECT1", ARM_IDLECT1);
+	DBPRINT("ARM_IDLECT2", ARM_IDLECT2);
+	DBPRINT("ARM_IDLECT3", ARM_IDLECT3);
+	DBPRINT("OMAP_DMA_GCR_REG", OMAP_DMA_GCR_REG);
+	DBPRINT("PERSEUS2_MODE_1", PERSEUS2_MODE_1);
+	DBPRINT("ULPD_SOFT_DISABLE_REQ_REG", SOFT_DISABLE_REQ_REG);
+	DBPRINT("ULPD_CAM_CLK_CTRL", CAM_CLK_CTRL);
+	DBPRINT("EAC_AGCTR", EAC_AGCTR);
+	DBPRINT("EAC_AGCFR", EAC_AGCFR);
+	DBPRINT("EAC_AGCFR2", EAC_AGCFR2);
+	DBPRINT("EAC_CPTCTL", EAC_CPTCTL);
+	DBPRINT("EAC_CPCFR1", EAC_CPCFR1);
+	DBPRINT("EAC_CPCFR2", EAC_CPCFR2);
+	DBPRINT("EAC_CPCFR3", EAC_CPCFR3);
+	DBPRINT("EAC_CPCFR4", EAC_CPCFR4);
+	DBPRINT("EAC_AMVCTR", EAC_AMVCTR);
+	DBPRINT("EAC_AM1VCTR", EAC_AM1VCTR);
+	DBPRINT("EAC_AM2VCTR", EAC_AM2VCTR);
+	DBPRINT("EAC_AM3VCTR", EAC_AM3VCTR);
+	DBPRINT("EAC_AMSCFR", EAC_AMSCFR);
+	DBPRINT("EAC_MPCTR", EAC_MPCTR);
+	DBPRINT("EAC_MPMCCFR", EAC_MPMCCFR);
+	DBPRINT("EAC_BPCTR", EAC_BPCTR);
+	DBPRINT("EAC_BPMCCFR", EAC_BPMCCFR);
+	DBPRINT("SOFT_REQ_REG", SOFT_REQ_REG);
+	DBPRINT("PCC_PERIPH_CLOCK_SOURCE_SEL", PCC_PERIPH_CLOCK_SOURCE_SEL);
+#endif
+}
+
+
+static void omap730_eac_write(__u16* addr, __u16 data) 
+{
+	DPRINTK("%s: addr 0x%08x, data 0x%04x\n", __FUNCTION__, (int) addr, data);
+	*((__u16 *) addr) = data;
+}
+
+static u16 omap730_eac_read(__u16* addr) 
+{
+	__u16 data;
+	
+	data = *((__u16 *) addr);
+	DPRINTK("%s: addr 0x%08x, data 0x%04x\n", __FUNCTION__, (int) addr, data);
+
+	return data;
+}
+
+static void eac_update(void)
+{
+        u16 volume, line;
+	u16 mixer1_vol, mixer2_vol, mixer3_vol;
+	u16 reg1_vol, reg2_vol, reg3_vol;
+	int clock_enabled;
+
+	FN_IN;
+
+	// Enable the EAC clock if needed
+	if (!(clock_enabled = omap730_getclock()))
+		omap730_setclock(1);
+
+	// PCM -> Mixer 2B & 3B
+	// LINE & MIC -> Mixer 1A & 3A
+
+       	// Convert % to Gain
+  	volume = ((eac_local.volume * OUTPUT_VOLUME_RANGE) / 100) + OUTPUT_VOLUME_MIN;
+	line = ((eac_local.line * INPUT_VOLUME_RANGE) / 100) + INPUT_VOLUME_MIN;
+
+	// Calc the register value (Mixer1 B & Mixer2 A to 0)
+	mixer1_vol = (line << MIXER_x_A_GAIN_OFFSET) & MIXER_x_A_MASK;
+	mixer2_vol = (volume << MIXER_x_B_GAIN_OFFSET) & MIXER_x_B_MASK;
+	mixer3_vol = (line << MIXER_x_A_GAIN_OFFSET) & MIXER_x_A_MASK;
+	mixer3_vol |= (volume << MIXER_x_B_GAIN_OFFSET) & MIXER_x_B_MASK;
+
+	// Use some read/write/read algotithm to prevent strange EAC mixer registers access problem
+	reg1_vol = omap730_eac_read((u16 *) EAC_AM1VCTR);
+	reg2_vol = omap730_eac_read((u16 *) EAC_AM2VCTR);
+	reg3_vol = omap730_eac_read((u16 *) EAC_AM3VCTR);
+	// Apply volume to Mixer1
+       	omap730_eac_write((u16 *) EAC_AM1VCTR, mixer1_vol);
+	// Apply volume to Mixer2
+	omap730_eac_write((u16 *) EAC_AM2VCTR, mixer2_vol);
+	// Apply volume to Mixer3
+       	omap730_eac_write((u16 *) EAC_AM3VCTR, mixer3_vol);
+	mdelay(1);
+	// Check the registers values
+	reg1_vol = omap730_eac_read((u16 *) EAC_AM1VCTR);
+	reg2_vol = omap730_eac_read((u16 *) EAC_AM2VCTR);
+	reg3_vol = omap730_eac_read((u16 *) EAC_AM3VCTR);
+
+	// Feedback on the actual mixer settings
+	if (reg1_vol != mixer1_vol || reg2_vol != mixer2_vol || reg3_vol != mixer3_vol)
+	{
+		eac_local.volume = (100 * ((reg2_vol & MIXER_x_B_MASK) >> MIXER_x_B_GAIN_OFFSET) - OUTPUT_VOLUME_MIN) / OUTPUT_VOLUME_RANGE;
+		eac_local.line = eac_local.mic = (100 * ((reg1_vol & MIXER_x_A_MASK) >> MIXER_x_A_GAIN_OFFSET) - INPUT_VOLUME_MIN) / INPUT_VOLUME_RANGE;
+	}
+
+	// Disable the EAC clock if it was disabled when entering the function
+	if (!clock_enabled)
+		omap730_setclock(0);
+
+	FN_OUT(0);
+}
+
+static int mixer_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
+{
+        int val;
+        int gain;
+        int ret = 0;
+        int nr = _IOC_NR(cmd);
+
+	/*
+	 * We only accept mixer (type 'M') ioctls.
+	 */
+	FN_IN;
+        DPRINTK("%s: IOC_NR=0x%08x, IOC_DIR=0x%08x\n", __FUNCTION__, _IOC_NR(cmd), _IOC_DIR(cmd));
+	if (_IOC_TYPE(cmd) != 'M')
+	{ 
+		switch (cmd) {
+		case SNDCTL_DSP_OUTPUTCTL:
+		{
+			u16 val_tmp;
+			ret = get_user(val_tmp, (int *) arg);
+			if (ret)
+				return ret;
+			
+			ret = GTI_Output_CTRL(val_tmp);
+			FN_OUT(5);
+			return ret;
+		}
+
+		case SNDCTL_DSP_ABB_WRITE:
+		{
+	 		abb_register_write new_ctl;
+	
+			if (copy_from_user(&new_ctl, (abb_register_write *) arg,sizeof(abb_register_write)))
+				return -EFAULT;
+			else
+			{
+				ret = GSM_WriteAbb(new_ctl.Page, new_ctl.RegisterAddr, new_ctl.Value);
+			}
+			FN_OUT(44);
+			return ret;
+		}
+
+		case SNDCTL_DSP_ABB_READ:
+		{
+	 		abb_register_read new_ctl;
+	 		u16 value_read;
+	
+			if (copy_from_user(&new_ctl, (abb_register_read *) arg,sizeof(abb_register_read)))
+				return -EFAULT;
+			else
+			{
+				value_read = GSM_ReadAbb(new_ctl.Page, new_ctl.RegisterAddr);
+			}
+			FN_OUT(44);
+			return put_user(value_read, (u16 *)arg);
+		}
+		
+		case SNDCTL_DSP_VOICEBANDCTL:
+		{
+		 	audio_voicebandctl new_ctl;
+		
+			if (copy_from_user(&new_ctl, (audio_voicebandctl *) arg,sizeof(audio_voicebandctl)))
+				return -EFAULT;
+			else
+			{
+				ret = GTI_Voiceband_Ctl(new_ctl.vbctl1, new_ctl.vbctl2); 
+			}
+			FN_OUT(6);
+			return ret;
+		}
+		
+		case SNDCTL_DSP_AUDIOVOICE:
+		{
+		 	audio_voice new_ctl;
+		
+			if (copy_from_user(&new_ctl, (audio_voice *) arg,sizeof(audio_voice)))
+				return -EFAULT;
+			else
+			{
+				ret = GTI_Audio_Voice(new_ctl.Mute);
+			}
+			FN_OUT(6);
+			return ret;
+		}
+		
+		case SNDCTL_DSP_AUDIOPGA:
+		{
+		 	audio_pga new_ctl;
+		
+			if (copy_from_user(&new_ctl, (audio_pga *) arg,sizeof(audio_pga)))
+				return -EFAULT;
+			else
+			{
+				ret = GTI_Audio_PGA(new_ctl.Uplink, new_ctl.Gain);
+			}
+			FN_OUT(6-2);
+			return ret;
+		}
+			
+		case SNDCTL_DSP_SIDETONE:
+		{
+			u8 val_tmp;
+			ret = get_user(val_tmp, (u8 *) arg);
+			if (ret)
+				return ret;
+			
+			ret = GTI_Audio_Sidetone(val_tmp);
+			FN_OUT(7);
+			return ret;
+		}	
+	
+		case SNDCTL_DSP_ECHOCANC:
+		{
+			u16 val_tmp;
+			ret = get_user(val_tmp, (int *) arg);
+			if (ret)
+				return ret;
+			
+			ret = GTI_Audio_Echocanc(val_tmp);
+			FN_OUT(8);
+			return ret;
+		}
+	
+		case SNDCTL_DSP_ENHECHOCANC:
+		{
+		 	audio_enhechocanc new_ctl;
+		
+			if (copy_from_user(&new_ctl, (audio_enhechocanc *) arg,sizeof(audio_enhechocanc)))
+				return -EFAULT;
+			else
+			{
+				ret = GTI_Audio_EnhEchocanc(new_ctl.Flag, new_ctl.Para1, new_ctl.Para2, new_ctl.Para3, new_ctl.Para4, new_ctl.Para5);
+			}
+			FN_OUT(85);
+			return ret;
+		}
+			
+		case SNDCTL_DSP_AUDIOCODEC:
+		{
+		 	audio_codec new_ctl;
+		
+			if (copy_from_user(&new_ctl, (audio_codec *) arg,sizeof(audio_codec)))
+				return -EFAULT;
+			else
+			{
+				ret = GSM_SetupAudio( new_ctl.on_off, new_ctl.AudioMode, new_ctl.Gain, new_ctl.SampleFrequency);
+			}
+			FN_OUT(9);
+			return ret;
+		}
+	
+		case SNDCTL_DSP_AUDIOPROFILE:
+		{
+			u8 val_tmp;
+			ret = get_user(val_tmp, (u8 *) arg);
+			if (ret)
+				return ret;
+			
+			GTI_Audio_Profileload(val_tmp);
+			FN_OUT(9-5);
+			return 0;
+		}	
+	
+		case SNDCTL_DSP_BTCTRL:
+		{
+			u8 val_tmp;
+			ret = get_user(val_tmp, (u8 *) arg);
+			if (ret)
+				return ret;
+			
+			ret = bt_control(val_tmp);
+			FN_OUT(10);
+			return ret;
+		}
+		
+		case SNDCTL_DSP_BYPASSCTRL:
+		{
+			u8 val_tmp;
+			ret = get_user(val_tmp, (u8 *) arg);
+			if (ret)
+				return ret;
+			
+			modem_bypass(val_tmp);
+			FN_OUT(10);
+			return 0;
+		}
+			
+		case SNDCTL_DSP_CHGSWITCH:
+		{
+			u16 val_tmp;
+			ret = get_user(val_tmp, (u16 *) arg);
+			if (ret)
+				return ret;
+			
+			omap730_eac_write((u16 *) EAC_AMSCFR, val_tmp);
+			FN_OUT(10);
+			return 0;
+		}
+	
+		case SNDCTL_DSP_AUDIOBT:
+		{
+			*((volatile u32*) PERSEUS2_IO_CONF8) = 0x1111ddd1;
+			return 0;
+		}
+		
+		default:
+			/*
+			 * command without audio path business still expect be handled in "dsp" device.
+			 */
+			return -EINVAL;		
+		}
+	}		 
+
+	/*
+	 * Now we accept mixer (type 'M') ioctls.
+	 */
+
+	if (cmd == SOUND_MIXER_INFO) {
+		struct mixer_info mi;
+                
+		strncpy(mi.id, "SYREN", sizeof(mi.id));
+		strncpy(mi.name, "TI SYREN", sizeof(mi.name));
+		mi.modify_counter = eac_local.mod_cnt;
+		FN_OUT(1);
+		return copy_to_user((void *)arg, &mi, sizeof(mi));
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		ret = get_user(val, (int *)arg);
+		if (ret)
+			goto out;
+
+                // Ignore separate left/right channel for now,
+                // even the codec does support it.
+		gain = val & 255;
+
+		switch (nr) {
+		case SOUND_MIXER_PCM:
+			eac_local.volume = gain;
+			eac_local.mod_cnt++;
+			eac_update();
+			break;
+
+		case SOUND_MIXER_MIC:
+		case SOUND_MIXER_LINE:
+			eac_local.line = eac_local.mic = gain;
+			eac_local.mod_cnt++;
+			eac_update();
+			break;
+
+		case SOUND_MIXER_RECSRC:
+			break;
+
+		default:
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == 0 && _IOC_DIR(cmd) & _IOC_READ) {
+		ret = 0;
+
+		switch (nr) {
+		case SOUND_MIXER_PCM:        val = eac_local.volume;	break;
+		case SOUND_MIXER_LINE:       val = eac_local.line;	break;
+		case SOUND_MIXER_MIC:        val = eac_local.mic;	break;
+		case SOUND_MIXER_RECSRC:     val = REC_MASK;	break;
+		case SOUND_MIXER_RECMASK:    val = REC_MASK;	break;
+		case SOUND_MIXER_DEVMASK:    val = DEV_MASK;	break;
+		case SOUND_MIXER_CAPS:       val = 0;		break;
+		case SOUND_MIXER_STEREODEVS: val = 0;		break;
+		default:	val = 0;     ret = -EINVAL;	break;
+		}
+
+		if (ret == 0)
+			ret = put_user(val, (int *)arg);
+	}
+ out:
+	FN_OUT(0);
+	return ret;
+
+}
+
+static struct file_operations omap730_mixer_fops = {
+	ioctl:		mixer_ioctl,
+	owner:		THIS_MODULE
+};
+
+
+/*
+ * Audio interface
+ */
+
+static long audio_samplerate = AUDIO_RATE_DEFAULT;
+
+static void omap730_set_samplerate(long val)
+{
+        int fsint = 0;
+
+
+	FN_IN;
+	
+	/* We don't want to mess with clocks when frames are in flight */
+        // TODO - could call dma_flush_all, or could poll on
+        // enable bit to wait for DMA writes to stop.
+
+	/* wait for any frame to complete */
+	udelay(125);
+
+	DPRINTK("%s %d\n", __FUNCTION__, (int) val);
+
+#if 0
+        /*
+                Note: according to the issues which can't support MT function and
+        some critic code will be pushed back from V.1.14 to V.1.12!
+                dannywang,050710!
+        */
+        omap730_setclock(1);
+#endif
+	fsint = omap730_eac_read((u16 *) EAC_AGCFR) & ~EAC_AGCFR_FSINT_MASK;
+
+        /*
+         * We have the following clock sources:
+         * 13.000 MHz
+         *
+         *  Available sampling rates:
+         *  (48kHz,) 44.1kHz, 22 kHz, 11kHz, 8kHz
+         */
+        //if (val >= 48000)
+	//  {
+        //        val = 48000;
+	//	fsint = 0x0004;
+	//  }
+        //else 
+	if (val >= 44100)
+	  {
+                val = 44100;
+		fsint |= EAC_AGCFR_FSINT_44KHZ;
+	  }
+        else if (val >= 22050)
+	  {
+                val = 22050;
+		fsint |= EAC_AGCFR_FSINT_22KHZ;
+	  }
+        else if (val >= 11025)
+	  {
+                val = 11025;
+		fsint |= EAC_AGCFR_FSINT_11KHZ;
+	  }
+        else
+	  {
+                val = 8000;
+		fsint |= EAC_AGCFR_FSINT_8KHZ;
+	  }
+
+	omap730_eac_write((u16 *) EAC_AGCFR, fsint);
+	audio_samplerate = val;
+	FN_OUT(0);
+}
+
+static int omap730_getclock(void)
+{
+	return (omap730_eac_read((u16 *) EAC_AGCTR) & EAC_AGCTR_MCLK_EN);
+}
+
+/* Warning: init/deinit operation order is important to keep the codec in sync
+	with the I2S frames.
+   Init:   Enable Syren codec (GTI_SetupAudio(1))
+           Enable EAC Codec Port & Clocks (omap730_setclock(1))
+           Enable DMA
+   Deinit: Disable DMA
+           Disable EAC Codec Port & Clocks (omap730_setclock(0))
+	   Disable Syren codec (GTI_SetupAudio(0))
+*/
+static void omap730_setclock(int on_off)
+{
+    u16 agctr_temp, soft_temp;
+    u16 temp;
+    
+    agctr_temp = omap730_eac_read((u16 *) EAC_AGCTR) & ~EAC_AGCTR_RESERVED;
+    soft_temp = omap730_eac_read((u16 *) SOFT_REQ_REG);
+
+    if (on_off)
+    {
+	// Enable clock & disable low power
+	agctr_temp |= EAC_AGCTR_MCLK_EN;
+	agctr_temp &= ~EAC_AGCTR_EACPWD;
+	soft_temp |= SOFT_REQ_REG_EAC12M_DPLL_REQ;
+    	omap730_eac_write((u16 *) EAC_AGCTR, agctr_temp);
+    	mdelay(1);
+    	omap730_eac_write((u16 *) SOFT_REQ_REG, soft_temp);
+
+	// Enable C-Port
+	temp = omap730_eac_read((u16 *) EAC_CPTCTL);
+	temp |= EAC_CPTCTL_CPEN;
+	omap730_eac_write((u16 *) EAC_CPTCTL, temp);	
+    }
+    else 
+    {
+  	modem_bypass(1);  	
+	// Disable C-Port
+	temp = omap730_eac_read((u16 *) EAC_CPTCTL);
+	temp &= ~EAC_CPTCTL_CPEN;
+	omap730_eac_write((u16 *) EAC_CPTCTL, temp);	
+
+	// Disable clock & enable low power
+	agctr_temp &= ~EAC_AGCTR_MCLK_EN;
+	agctr_temp |= EAC_AGCTR_EACPWD;
+	soft_temp &= ~SOFT_REQ_REG_EAC12M_DPLL_REQ;
+    	omap730_eac_write((u16 *) SOFT_REQ_REG, soft_temp);
+    	omap730_eac_write((u16 *) EAC_AGCTR, agctr_temp);
+    	mdelay(1);
+    }
+
+}
+
+static void omap730_audio_init(void *dummy)
+{
+	FN_IN;
+
+        /*  
+            Configure the DMA channel and EAC
+        */
+
+	// DMA configuration already done
+	// Setup the I2S codec through the ARM7.
+//	GTI_SetupAudio(1);
+	// Enable EAC clocks
+#if 1
+        /*
+                Note: according to the issues which can't support MT function and
+        some critic code will be pushed back from V.1.14 to V.1.12!
+        */
+        omap730_setclock(1);
+                                                                                                                             
+        // Setup K switches for Phone Call + play/record
+        // omap730_eac_write((u16 *) EAC_AMSCFR, EAC_AMSCFR_DEFAULT_SWITCHES);
+                                                                                                                             
+        omap730_set_samplerate(audio_samplerate);
+                                                                                                                             
+#endif
+
+	eac_dump();
+
+	FN_OUT(0);
+}
+
+static void omap730_audio_shutdown(void *dummy)
+{
+	u16 temp;
+
+        /* 
+           Turn off codec after it is done.  
+           Can't do it immediately, since it may still have
+           buffered data.
+
+           Wait 20ms (arbitrary value) and then turn it off.
+        */
+        
+	FN_IN;
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(2);
+
+	// Audio Global Control Register 2
+	temp = omap730_eac_read((u16 *) EAC_AGCTR);
+	// DMA read and write operation disabled
+	temp &= ~(EAC_AGCTR_DMAWEN | EAC_AGCTR_DMAREN);
+	omap730_eac_write((u16 *) EAC_AGCTR, temp);
+	
+	// Shutdown the I2S codec through the ARM7.
+	omap730_setclock(0);
+	// Disable EAC clocks
+	//GTI_SetupAudio(0);
+
+	FN_OUT(0);
+}
+
+#ifdef CONFIG_CEE  /* MVL-CEE */
+extern void sleep_mode_ctrl(unsigned char mode);
+extern int vrio_mode_ctrl(unsigned char mode);
+
+static int omap730_audio_suspend(struct device *dev, u32 state, u32 level)
+{
+  extern void audio_ldm_suspend(void *data);
+
+  FN_IN;
+  switch(level)
+  {
+     case SUSPEND_POWER_DOWN: 
+
+       /* Turn off power to omap730_audio */
+        
+       audio_ldm_suspend(&audio_state);      
+       omap730_setclock(0);
+       sleep_mode_ctrl(4);
+       vrio_mode_ctrl(0);
+       //GTI_SetupAudio(0);
+
+       break;
+  }
+
+  FN_OUT(0);
+  return 0;
+}
+
+static int omap730_audio_resume(struct device *dev, u32 level)
+{
+  extern void audio_ldm_resume(void *data);
+
+  FN_IN;
+  switch(level)
+  {
+     case RESUME_POWER_ON:
+
+       /* Turn on power to omap730_audio */
+
+       //GTI_SetupAudio(1);
+       omap730_setclock(1);
+       audio_ldm_resume(&audio_state);
+       vrio_mode_ctrl(1);
+       break;
+  }
+
+  FN_OUT(0);
+  return 0;
+}
+
+#endif
+
+
+static int omap730_audio_ioctl(struct inode *inode, struct file *file,
+                                uint cmd, ulong arg)
+{
+	long val;
+	int ret = 0;
+
+	DPRINTK("%s 0x%08x\n", __FUNCTION__, cmd);
+
+	/*
+	 * These are platform dependent ioctls which are not handled by the
+	 * generic omap-audio module.
+	 */
+	switch (cmd) {
+	case SNDCTL_DSP_STEREO:
+		ret = get_user(val, (int *) arg);
+		if (ret)
+			return ret;
+		/* the SYREN is stereo only */
+		ret = (val == 0) ? -EINVAL : 1;
+		FN_OUT(1);
+		return put_user(ret, (int *) arg);
+
+	case SNDCTL_DSP_CHANNELS:
+	case SOUND_PCM_READ_CHANNELS:
+		/* the AIC23 is stereo only */
+		FN_OUT(2);
+		return put_user(2, (long *) arg);
+
+	case SNDCTL_DSP_SPEED:
+		ret = get_user(val, (long *) arg);
+		if (ret) break;
+		omap730_set_samplerate(val);
+		/* fall through */
+
+	case SOUND_PCM_READ_RATE:
+		FN_OUT(3);
+		return put_user(audio_samplerate, (long *) arg);
+
+	case SNDCTL_DSP_SETFMT:
+	case SNDCTL_DSP_GETFMTS:
+		/* we can do 16-bit only */
+		FN_OUT(4);
+		return put_user(AFMT_S16_LE, (long *) arg);
+	case SNDCTL_DSP_ABB_WRITE:
+	{
+	 	abb_register_write new_ctl;
+	
+		if (copy_from_user(&new_ctl, (abb_register_write *) arg,sizeof(abb_register_write)))
+			return -EFAULT;
+		else
+		{
+			ret = GSM_WriteAbb(new_ctl.Page, new_ctl.RegisterAddr, new_ctl.Value);
+		}
+		FN_OUT(44);
+		return ret;
+	}
+
+	case SNDCTL_DSP_ABB_READ:
+	{
+	 	abb_register_read new_ctl;
+	 	u16 value_read;
+	
+		if (copy_from_user(&new_ctl, (abb_register_read *) arg,sizeof(abb_register_read)))
+			return -EFAULT;
+		else
+		{
+			value_read = GSM_ReadAbb(new_ctl.Page, new_ctl.RegisterAddr);
+		}
+		FN_OUT(44);
+		return put_user(value_read, (u16 *)arg);
+	}
+		
+	case SNDCTL_DSP_OUTPUTCTL:
+	{
+		u16 val_tmp;
+		ret = get_user(val_tmp, (int *) arg);
+		if (ret)
+			return ret;
+		
+		ret = GTI_Output_CTRL(val_tmp);
+		FN_OUT(5);
+		return ret;
+	}
+
+	case SNDCTL_DSP_VOICEBANDCTL:
+	{
+	 	audio_voicebandctl new_ctl;
+	
+		if (copy_from_user(&new_ctl, (audio_voicebandctl *) arg,sizeof(audio_voicebandctl)))
+			return -EFAULT;
+		else
+		{
+			ret = GTI_Voiceband_Ctl(new_ctl.vbctl1, new_ctl.vbctl2); 
+		}
+		FN_OUT(6);
+		return ret;
+	}
+
+	case SNDCTL_DSP_AUDIOVOICE:
+	{
+	 	audio_voice new_ctl;
+	
+		if (copy_from_user(&new_ctl, (audio_voice *) arg,sizeof(audio_voice)))
+			return -EFAULT;
+		else
+		{
+			ret = GTI_Audio_Voice(new_ctl.Mute);
+		}
+		FN_OUT(6);
+		return ret;
+	}
+
+	case SNDCTL_DSP_AUDIOPGA:
+	{
+	 	audio_pga new_ctl;
+	
+		if (copy_from_user(&new_ctl, (audio_pga *) arg,sizeof(audio_pga)))
+			return -EFAULT;
+		else
+		{
+			ret = GTI_Audio_PGA(new_ctl.Uplink, new_ctl.Gain);
+		}
+		FN_OUT(6-2);
+		return ret;
+	}
+		
+	case SNDCTL_DSP_SIDETONE:
+	{
+		u8 val_tmp;
+		ret = get_user(val_tmp, (u8 *) arg);
+		if (ret)
+			return ret;
+		
+		ret = GTI_Audio_Sidetone(val_tmp);
+		FN_OUT(7);
+		return ret;
+	}	
+
+	case SNDCTL_DSP_ECHOCANC:
+	{
+		u16 val_tmp;
+		ret = get_user(val_tmp, (int *) arg);
+		if (ret)
+			return ret;
+		
+		ret = GTI_Audio_Echocanc(val_tmp);
+		FN_OUT(8);
+		return ret;
+	}
+
+	case SNDCTL_DSP_ENHECHOCANC:
+	{
+	 	audio_enhechocanc new_ctl;
+	
+		if (copy_from_user(&new_ctl, (audio_enhechocanc *) arg,sizeof(audio_enhechocanc)))
+			return -EFAULT;
+		else
+		{
+			ret = GTI_Audio_EnhEchocanc(new_ctl.Flag, new_ctl.Para1, new_ctl.Para2, new_ctl.Para3, new_ctl.Para4, new_ctl.Para5);
+		}
+		FN_OUT(85);
+		return ret;
+	}
+		
+	case SNDCTL_DSP_AUDIOCODEC:
+	{
+	 	audio_codec new_ctl;
+	
+		if (copy_from_user(&new_ctl, (audio_codec *) arg,sizeof(audio_codec)))
+			return -EFAULT;
+		else
+		{
+			ret = GSM_SetupAudio( new_ctl.on_off, new_ctl.AudioMode, new_ctl.Gain, new_ctl.SampleFrequency);
+		}
+		FN_OUT(9);
+		return ret;
+	}
+
+	case SNDCTL_DSP_AUDIOPROFILE:
+	{
+		u8 val_tmp;
+		ret = get_user(val_tmp, (u8 *) arg);
+		if (ret)
+			return ret;
+		
+		GTI_Audio_Profileload(val_tmp);
+		FN_OUT(9-5);
+		return 0;
+	}	
+
+	case SNDCTL_DSP_BTCTRL:
+	{
+		u8 val_tmp;
+		ret = get_user(val_tmp, (u8 *) arg);
+		if (ret)
+			return ret;
+		
+		ret = bt_control(val_tmp);
+		FN_OUT(10);
+		return ret;
+	}
+	
+	case SNDCTL_DSP_BYPASSCTRL:
+	{
+		u8 val_tmp;
+		ret = get_user(val_tmp, (u8 *) arg);
+		if (ret)
+			return ret;
+		
+		modem_bypass(val_tmp);
+		FN_OUT(10);
+		return 0;
+	}
+		
+	case SNDCTL_DSP_CHGSWITCH:
+	{
+		u16 val_tmp;
+		ret = get_user(val_tmp, (u16 *) arg);
+		if (ret)
+			return ret;
+		
+		omap730_eac_write((u16 *) EAC_AMSCFR, val_tmp);
+		FN_OUT(10);
+		return 0;
+	}			
+	case SNDCTL_DSP_DUMP_REG:
+	{
+#ifdef DEBUG
+	DBPRINT("PERSEUS2_IO_CONF0", REG32(PERSEUS2_IO_CONF0));
+	DBPRINT("PERSEUS2_IO_CONF1", REG32(PERSEUS2_IO_CONF1));
+	DBPRINT("PERSEUS2_IO_CONF2", REG32(PERSEUS2_IO_CONF2));
+	DBPRINT("PERSEUS2_IO_CONF3", REG32(PERSEUS2_IO_CONF3));
+	DBPRINT("PERSEUS2_IO_CONF4", REG32(PERSEUS2_IO_CONF4));
+	DBPRINT("PERSEUS2_IO_CONF5", REG32(PERSEUS2_IO_CONF5));
+	DBPRINT("PERSEUS2_IO_CONF6", REG32(PERSEUS2_IO_CONF6));
+	DBPRINT("PERSEUS2_IO_CONF7", REG32(PERSEUS2_IO_CONF7));
+	DBPRINT("PERSEUS2_IO_CONF8", REG32(PERSEUS2_IO_CONF8));
+	DBPRINT("PERSEUS2_IO_CONF9", REG32(PERSEUS2_IO_CONF9));
+	DBPRINT("PERSEUS2_IO_CONF10", REG32(PERSEUS2_IO_CONF10));
+	DBPRINT("PERSEUS2_IO_CONF11", REG32(PERSEUS2_IO_CONF11));
+	DBPRINT("PERSEUS2_IO_CONF12", REG32(PERSEUS2_IO_CONF12));
+	DBPRINT("PERSEUS2_IO_CONF13", REG32(PERSEUS2_IO_CONF13));
+	
+	DBPRINT("PERSEUS2_MODE_1", REG32(PERSEUS2_MODE_1));
+	
+	DBPRINT("MPUIO_KBR_LATCH", REG32(MPUIO_KBR_LATCH));
+	DBPRINT("MPUIO_KBC_REG", REG32(MPUIO_KBC_REG));
+		
+#if 0	
+	DBPRINT("GPIO_MOTOR", REG32(GPIO_DATA_OUTPUT_REG + ((GPIO_MOTOR_ENABLE_NUM / OMAP730_GPIO_NB) * OMAP730_GPIO_SIZE)));
+
+	//DBPRINT("GPIO_HEADSET 0", (*(REG32(GPIO_DATA_INPUT_REG + ((GPIO_HEADSET_DETECT_NUM / OMAP730_GPIO_NB) * OMAP730_GPIO_SIZE)))) >> (GPIO_HEADSET_DETECT_NUM % OMAP730_GPIO_NB)) & 1);
+	//DBPRINT("GPIO_HEADSET 1",REG32(GPIO_DATA_INPUT_REG + ((GPIO_HEADSET_DETECT_NUM / OMAP730_GPIO_NB) * OMAP730_GPIO_SIZE)));
+	DBPRINT("GPIO_HOOK_DET_IRQ_NUM 1",GPIO_DATA_INPUT_REG + ((GPIO_HOOK_DET_IRQ_NUM / OMAP730_GPIO_NB) * OMAP730_GPIO_SIZE));
+	
+	DBPRINT("DPLL1_CTL_REG", DPLL1_CTL_REG);
+	DBPRINT("ARM_SYSST", ARM_SYSST);
+	DBPRINT("ARM_CKCTL", ARM_CKCTL);
+	DBPRINT("PCC_CTRL_REG", PCC_CTRL_REG);
+	DBPRINT("ARM_RSTCT2", ARM_RSTCT2);
+	DBPRINT("ARM_IDLECT1", ARM_IDLECT1);
+	DBPRINT("ARM_IDLECT2", ARM_IDLECT2);
+	DBPRINT("ARM_IDLECT3", ARM_IDLECT3);
+	DBPRINT("OMAP_DMA_GCR_REG", OMAP_DMA_GCR_REG);
+	DBPRINT("PERSEUS2_MODE_1", PERSEUS2_MODE_1);
+	DBPRINT("ULPD_SOFT_DISABLE_REQ_REG", SOFT_DISABLE_REQ_REG);
+	DBPRINT("ULPD_CAM_CLK_CTRL", CAM_CLK_CTRL);
+	DBPRINT("EAC_AGCTR", EAC_AGCTR);
+	DBPRINT("EAC_AGCFR", EAC_AGCFR);
+	DBPRINT("EAC_AGCFR2", EAC_AGCFR2);
+	DBPRINT("EAC_CPTCTL", EAC_CPTCTL);
+	DBPRINT("EAC_CPCFR1", EAC_CPCFR1);
+	DBPRINT("EAC_CPCFR2", EAC_CPCFR2);
+	DBPRINT("EAC_CPCFR3", EAC_CPCFR3);
+	DBPRINT("EAC_CPCFR4", EAC_CPCFR4);
+	DBPRINT("EAC_AMVCTR", EAC_AMVCTR);
+	DBPRINT("EAC_AM1VCTR", EAC_AM1VCTR);
+	DBPRINT("EAC_AM2VCTR", EAC_AM2VCTR);
+	DBPRINT("EAC_AM3VCTR", EAC_AM3VCTR);
+	DBPRINT("EAC_AMSCFR", EAC_AMSCFR);
+	DBPRINT("EAC_MPCTR", EAC_MPCTR);
+	DBPRINT("EAC_MPMCCFR", EAC_MPMCCFR);
+	DBPRINT("EAC_BPCTR", EAC_BPCTR);
+	DBPRINT("EAC_BPMCCFR", EAC_BPMCCFR);
+	DBPRINT("SOFT_REQ_REG", SOFT_REQ_REG);
+	DBPRINT("PCC_PERIPH_CLOCK_SOURCE_SEL", PCC_PERIPH_CLOCK_SOURCE_SEL);
+#endif
+#endif
+
+		return 0;
+	}	
+	//#define MPUIO_KBR_LATCH            (OMAP730_ARMIO_BASE + 0x08)
+	//#define MPUIO_KBC_REG              (OMAP730_ARMIO_BASE + 0x0a)
+
+	case SNDCTL_DSP_AUDIOBT:
+	{
+		*((volatile u32*) PERSEUS2_IO_CONF8) = 0x1111ddd1;
+		return 0;
+	}
+
+	case GPIO_NEW_SETUP:
+	{
+	 	gpio_para new_gpio;
+	
+		if (copy_from_user(&new_gpio, (gpio_para *) arg,sizeof(new_gpio)))
+			return -EFAULT;
+		else
+		{
+			GPIO_SET_DIR(new_gpio.pin, new_gpio.pin_dir);    \
+			GPIO_SET_STATE(new_gpio.pin, new_gpio.pin_def);   
+		}
+		
+	}
+		return 0;
+
+	case GPIO_GET_INPUT:
+	{
+		int val;
+        	int ret = 0;
+        	int result;
+		ret = get_user(val, (int *)arg);
+		//GPIO_SET_STATE(val, 0);
+		result = GPIO_GET_INPUT_STATE(val);
+		printk("GPIO %d data is 0x%x \n", val, result);
+	}
+		return 0;	
+
+	case GPIO_GET_OUTPUT:
+	{
+		int val;
+        	int ret = 0;
+        	int result;
+		ret = get_user(val, (int *)arg);
+		//GPIO_SET_STATE(val, 0);
+		result = GPIO_GET_OUTPUT_STATE(val);
+		printk("GPIO %d data is 0x%x \n", val, result);
+	}
+		return 0;
+		
+	case SNDCTL_DSP_SYREN_READ:
+		return put_user(syren_codec_onoff, (u8 *) arg);
+					
+	default:
+		/* Maybe this is meant for the mixer (As per OSS Docs) */
+		FN_OUT(12);
+		return mixer_ioctl(inode, file, cmd, arg);
+	}
+
+	FN_OUT(0);
+	return ret;
+}
+
+static int omap730_audio_open(struct inode *inode, struct file *file)
+{
+	return omap_audio_attach(inode, file, &audio_state);
+}
+
+#ifdef EAC_PROC_SUPPORT
+/*
+	DBPRINT("EAC_AGCTR", EAC_AGCTR);
+	DBPRINT("EAC_AGCFR", EAC_AGCFR);
+	DBPRINT("EAC_AGCFR2", EAC_AGCFR2);
+	DBPRINT("EAC_CPTCTL", EAC_CPTCTL);
+	DBPRINT("EAC_CPCFR1", EAC_CPCFR1);
+	DBPRINT("EAC_CPCFR2", EAC_CPCFR2);
+	DBPRINT("EAC_CPCFR3", EAC_CPCFR3);
+	DBPRINT("EAC_CPCFR4", EAC_CPCFR4);
+	DBPRINT("EAC_AMVCTR", EAC_AMVCTR);
+	DBPRINT("EAC_AM1VCTR", EAC_AM1VCTR);
+	DBPRINT("EAC_AM2VCTR", EAC_AM2VCTR);
+	DBPRINT("EAC_AM3VCTR", EAC_AM3VCTR);
+	DBPRINT("EAC_AMSCFR", EAC_AMSCFR);
+	DBPRINT("EAC_MPCTR", EAC_MPCTR);
+	DBPRINT("EAC_MPMCCFR", EAC_MPMCCFR);
+	DBPRINT("EAC_BPCTR", EAC_BPCTR);
+	DBPRINT("EAC_BPMCCFR", EAC_BPMCCFR);
+*/
+static struct proc_dir_entry *eac_dir = NULL;
+static struct proc_dir_entry *AGCTR_entry = NULL;
+
+static int create_eac_proc(void)
+{
+	eac_dir = proc_mkdir("eac", NULL);
+	AGCTR_entry = create_proc_entry("AGCTR", S_IFREG | 0644, eac_dir);
+	if(AGCTR_entry == NULL)
+		return -EINVAL;
+
+
+	return 0;
+}
+#endif
+/*
+ * Missing fields of this structure will be patched with the call
+ * to omap_audio_attach().
+ */
+static struct file_operations omap730_audio_fops = {
+	open:		omap730_audio_open,
+	owner:		THIS_MODULE
+};
+
+static int GSM_WriteAbb(u16 Page,u16 RegisterAddr,u16 Value)
+{
+	CSMI_INFO_GC_ABB_REGISTER_REQ   infoGcReq;
+	CSMI_INFO_GC_ABB_REGISTER_RES	infoGcRes;
+	u32 ret;
+	DPRINTK("in GSM_WriteAbb\n");
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_ABB_REGISTER_REQ));
+	memset(&infoGcRes, 0, sizeof(CSMI_INFO_GC_ABB_REGISTER_RES));
+	
+	infoGcReq.PrimitiveCode = GC_ABB_REGISTER_REQ;
+
+	infoGcReq.WriteAccess = 1; //0=read | 1=write
+	infoGcReq.Page = Page + 1;
+	infoGcReq.RegisterAddr = RegisterAddr;
+	infoGcReq.Value = Value; //0=read | 1=write
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_ABB_REGISTER_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     (u8*) &infoGcRes,
+			     sizeof(infoGcRes),
+			     NULL);
+	if((ret == FALSE) || (infoGcRes.Value == 0xFFFF))
+		DPRINTK("Write ABB failed\n");
+	else
+		DPRINTK("Write ABB success\n");
+	return ((ret != FALSE) && (infoGcRes.Value == 0x0000)) ? 0:-1;
+}
+
+static u16 GSM_ReadAbb(u16 Page,u16 RegisterAddr)
+{
+	CSMI_INFO_GC_ABB_REGISTER_REQ   infoGcReq;
+	CSMI_INFO_GC_ABB_REGISTER_RES	infoGcRes;
+	u32 ret;
+	DPRINTK("in GSM_ReadAbb\n");
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_ABB_REGISTER_REQ));
+	memset(&infoGcRes, 0, sizeof(CSMI_INFO_GC_ABB_REGISTER_RES));
+		
+	infoGcReq.PrimitiveCode = GC_ABB_REGISTER_REQ;
+
+	infoGcReq.WriteAccess = 0; //0=read | 1=write
+	infoGcReq.Page = Page + 1;
+	infoGcReq.RegisterAddr = RegisterAddr;
+	infoGcReq.Value = 0; //0=read | 1=write
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_ABB_REGISTER_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     (u8*) &infoGcRes,
+			     sizeof(infoGcRes),
+			     NULL);
+	if((ret == FALSE) || (infoGcRes.Value == 0xFFFF))
+		DPRINTK("Read ABB failed\n");
+	else
+	{
+		DPRINTK("Read ABB success\n");
+		printk("register value = %d\n", infoGcRes.Value);
+	}
+	return ((ret != FALSE) && (infoGcRes.Value != 0xFFFF)) ? infoGcRes.Value:0;
+}
+/*
+ *  GSM_SetupAudio
+ *
+ *  Setup the audio codec on the ARM7 side.
+ *
+ *  Param: TRUE/FALSE for respectively ON/OFF
+ *
+ *  Default params:
+ *   - ControlCode = GC_STEREO_ON
+ *   - AudioMode = GC_SPEAKER_MODE
+ *   - Gain = 16
+ *   - SampleFrequency = GC_SAMPLE_FREQ_48000
+ *
+ *  Returns 0 if OK, -1 if not OK
+ */
+static int GSM_SetupAudio( u8 on_off, u8 AudioMode,u8 Gain, u8 SampleFrequency)
+{
+	CSMI_INFO_GC_AUDIO_STEREO_REQ   infoGcReq;
+	CSMI_INFO_GC_AUDIO_STEREO_RES	infoGcRes;
+	u32 ret;
+	DPRINTK("in GSM_SetupAudio\n");
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_STEREO_REQ));
+	memset(&infoGcRes, 0, sizeof(CSMI_INFO_GC_AUDIO_STEREO_RES));
+		
+	infoGcReq.PrimitiveCode = GC_AUDIO_STEREO_CODEC_REQ;
+//	infoGcReq.ControlCode = (on_off == TRUE) ? GC_STEREO_ON:GC_STEREO_OFF;
+//	infoGcReq.AudioMode = GC_SPEAKER_MODE;
+//	infoGcReq.Gain = 16;
+//	infoGcReq.SampleFrequency = GC_SAMPLE_FREQ_48000;
+	infoGcReq.ControlCode = on_off;//(on_off == 1) ? GC_STEREO_ON:GC_STEREO_OFF;
+	infoGcReq.AudioMode = AudioMode;
+	infoGcReq.Gain = Gain;
+	infoGcReq.SampleFrequency = SampleFrequency;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_STEREO_CODEC_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     (u8*) &infoGcRes,
+			     sizeof(infoGcRes),
+			     NULL);
+	if((ret == FALSE) || (infoGcRes.Result != TRUE))
+		DPRINTK("setup audio failed\n");
+	else if ((ret != FALSE) && (infoGcRes.Result == TRUE))
+	{
+		if (on_off == 1)
+			syren_codec_onoff = 1;
+		if (on_off == 0)
+			syren_codec_onoff = 0;
+	}
+	return ((ret != FALSE) && (infoGcRes.Result == TRUE)) ? 0:-1;
+}
+
+static int GTI_Audio_Echocanc(u16 Algorithm)
+{
+	CSMI_INFO_GC_AUDIO_ECHOCANC_REQ   infoGcReq;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_ECHOCANC_REQ));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_ECHOCANC_REQ;
+	infoGcReq.Algorithm = Algorithm;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_ECHOCANC_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     NULL,
+			     0,
+			     NULL);
+	if(ret == FALSE)
+		DPRINTK("audio echocanc failed!\n");
+	else
+		DPRINTK("audio echocanc success!\n");
+	return (ret != FALSE) ? 0:-1;
+}
+
+static int GTI_Output_CTRL(u16 vauoctl)
+{
+	CSMI_INFO_GC_AUDIO_OUTPUTCTL_REQ   infoGcReq;
+	CSMI_INFO_GC_AUDIO_OUTPUTCTL_RES	infoGcRes;
+
+	u32 ret;
+	FN_IN;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_OUTPUTCTL_REQ));
+	memset(&infoGcRes, 0, sizeof(CSMI_INFO_GC_AUDIO_OUTPUTCTL_RES));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_OUTPUTCTL_REQ;
+	infoGcReq.vauoctl = vauoctl;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL, //CSMI_SendToMailbox(CSMI_PORT portIndex,CSMI_MAILBOX *pP)
+			     GC_AUDIO_OUTPUTCTL_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     (u8*) &infoGcRes,
+			     sizeof(infoGcRes),
+			     NULL);
+	if((ret == FALSE) || (infoGcRes.Result != TRUE))
+		printk("audio output ctrl failed!\n");
+	else
+		DPRINTK("audio output ctrl success!\n");
+	FN_OUT(0);
+	return ((ret != FALSE) && (infoGcRes.Result == TRUE)) ? 0:-1;
+}
+
+static int GTI_Voiceband_Ctl(u16 vbctl1, u16 vbctl2)
+{
+	CSMI_INFO_GC_AUDIO_VOICEBANDCTL_REQ   infoGcReq;
+	CSMI_INFO_GC_AUDIO_VOICEBANDCTL_RES	infoGcRes;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_VOICEBANDCTL_REQ));
+	memset(&infoGcRes, 0, sizeof(CSMI_INFO_GC_AUDIO_VOICEBANDCTL_RES));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_VOICEBANDCTL_REQ;
+	infoGcReq.vbctl1 = vbctl1;
+	infoGcReq.vbctl2 = vbctl2;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_VOICEBANDCTL_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     (u8*) &infoGcRes,
+			     sizeof(infoGcRes),
+			     NULL);
+	if((ret == FALSE) || (infoGcRes.Result != TRUE))
+		DPRINTK("audio voice band ctrl failed!\n");
+	else
+		DPRINTK("audio voice band ctrl success!\n");
+	return ((ret != FALSE) && (infoGcRes.Result == TRUE)) ? 0:-1;
+}
+
+//static int GTI_Audio_Voice(u8 Uplink, u8 Mute, u8 Volume)
+static int GTI_Audio_Voice(u8 Mute)
+{
+	CSMI_INFO_GC_AUDIO_VOICE_REQ   infoGcReq;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_VOICE_REQ));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_VOICE_REQ;
+	//infoGcReq.Uplink = Uplink;
+	infoGcReq.Mute = Mute;
+	//infoGcReq.Volume = Volume;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_VOICE_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     NULL,
+			     0,
+			     NULL);
+	if(ret == FALSE)
+		DPRINTK("audio voice band ctrl failed!\n");
+	else
+		DPRINTK("audio voice band ctrl success!\n");
+	return (ret != FALSE) ? 0:-1;
+}
+
+static int GTI_Audio_EnhEchocanc(u16 Flag, u16 Para1, u16 Para2, u16 Para3, u16 Para4, u16 Para5)
+{
+	CSMI_INFO_GC_AUDIO_ENHECHOCANC_REQ   infoGcReq;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_ENHECHOCANC_REQ));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_ENHECHOCANC_REQ;
+	infoGcReq.Flag = Flag;
+	infoGcReq.P1 = Para1;
+	infoGcReq.P2 = Para2;
+	infoGcReq.P3 = Para3;
+	infoGcReq.P4 = Para4;
+	infoGcReq.P5 = Para5;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_ENHECHOCANC_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     NULL,
+			     0,
+			     NULL);
+	if(ret == FALSE)
+		DPRINTK("AUDIO_ENHECHOCANC failed!\n");
+	else
+		DPRINTK("AUDIO_ENHECHOCANC success!\n");
+	return (ret != FALSE) ? 0:-1;	
+}
+
+static int GTI_Audio_PGA(u8 Uplink, u8 Gain)
+{
+	CSMI_INFO_GC_AUDIO_PGA_REQ   infoGcReq;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_PGA_REQ));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_PGA_REQ;
+	infoGcReq.Uplink = Uplink;
+	infoGcReq.Gain = Gain;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_PGA_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     NULL,
+			     0,
+			     NULL);
+	if(ret == FALSE)
+		DPRINTK("audio PGA failed!\n");
+	else
+		DPRINTK("audio PGA success!\n");
+	return (ret != FALSE) ? 0:-1;
+}
+
+static int GTI_Audio_Sidetone(u8 Volume)
+{
+	CSMI_INFO_GC_AUDIO_SIDETONE_REQ   infoGcReq;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_SIDETONE_REQ));
+	
+	infoGcReq.PrimitiveCode = GC_AUDIO_SIDETONE_REQ;
+	infoGcReq.Volume = Volume;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_SIDETONE_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     NULL,
+			     0,
+			     NULL);
+	if(ret == FALSE)
+		DPRINTK("audio voice band ctrl failed!\n");
+	else
+		DPRINTK("audio voice band ctrl success!\n");
+	return (ret != FALSE) ? 0:-1;
+}
+
+static int GTI_Audio_Profileload(u8 Profile)
+{
+	CSMI_INFO_GC_AUDIO_PROFILE_LOAD_REQ	infoGcReq;
+	CSMI_INFO_GC_AUDIO_PROFILE_LOAD_RES	infoGcRes;
+	u32 ret;
+	
+	memset(&infoGcReq, 0, sizeof(CSMI_INFO_GC_AUDIO_PROFILE_LOAD_REQ));
+	memset(&infoGcRes, 0, sizeof(CSMI_INFO_GC_AUDIO_PROFILE_LOAD_RES));
+		
+	infoGcReq.PrimitiveCode = GC_AUDIO_PROFILE_LOAD_REQ;
+	infoGcReq.Profile = Profile;
+
+	ret =  GTI_IOControl(CSMI_PORT_INDEX_GSMCTRL,
+			     GC_AUDIO_PROFILE_LOAD_REQ,
+			     (u8*) &infoGcReq,
+			     sizeof(infoGcReq),
+			     (u8*) &infoGcRes,
+			     sizeof(infoGcRes),
+			     NULL);
+	if((ret == FALSE) || (infoGcRes.Result != TRUE))
+		DPRINTK("audio profile load failed!\n");
+	else
+		DPRINTK("audio profile load success!\n");
+	return ((ret != FALSE) && (infoGcRes.Result == TRUE)) ? 0:-1;	
+}
+static int bt_control(int on_off)
+{
+	DPRINTK("on_off = %d\n",on_off);
+	switch(on_off)
+	{
+		case 0: // disable
+			// system setup to support EAC 
+			// while also can diable EAC using bypass path when calling
+			// D_SYREN_VOICE: SCLK, SDO, SDI, FSYNC
+		    	//*((volatile __u32 *) PERSEUS2_IO_CONF2) &= 0xFFFFFF1F;
+			*((volatile u32*) PERSEUS2_IO_CONF2) &= 0xFFFFFF0F;	
+			*((volatile u32*) PERSEUS2_IO_CONF2) |= 0x00000010;	
+			*((volatile u32*) PERSEUS2_IO_CONF8) = 0x1111ddd1;
+			*((volatile u32*) PERSEUS2_IO_CONF9) = 0x15bbbddd;
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFF3;
+			
+			// INTERNAL_GSM_VOICE_SOURCE: Internal EAC Modem AuSPI
+			// bits 1:0 = 01: Internal EAC modem AuSPI
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFFC;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000001; 									
+		break;
+		
+		case 1: // bt enable
+			*((volatile u32*) PERSEUS2_IO_CONF2) &= 0xFFFFFF0F;	
+			*((volatile u32*) PERSEUS2_IO_CONF2) |= 0x000000D0;	
+			*((volatile u32*) PERSEUS2_IO_CONF8) = 0x3333ddd1; //0x2222ddd1; // 0x3333ddd1
+			*((volatile u32*) PERSEUS2_IO_CONF9) = 0x15bbbddd;
+			// INTERNAL_EAC_BT_AUSPI_SOURC: Pins BT AuSPI : SCLK, SDI, FSYNC
+			// bits 3:2 = 01: Pins MPU_SPI: MPU_SCLK, MPU_SDI,
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFF3;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000004;
+			
+			// INTERNAL_GSM_VOICE_SOURCE: Internal EAC Modem AuSPI
+			// bits 1:0 = 01: Internal EAC modem AuSPI
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFFC;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000001; 
+#if 0	// HIGH END app
+			// INTERNAL_GSM_VOICE_SOURCE: Internal EAC Modem AuSPI
+			// bits 1:0 = 01: Internal EAC modem AuSPI
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFFC;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000001; 
+			
+			// INTERNAL_EAC_BT_AUSPI_SOURC: Pins BT AuSPI : SCLK, SDI, FSYNC
+			// bits 3:2 = 00: Pins MPU_SPI: MPU_SCLK, MPU_SDI,
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFF3;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000000;
+			
+			// D_EAC pins: D_SPI1_SEN0, D_SPI1_SDI, D_SPI1_SDO, D_SPI1_SCLK
+			// bits 31:29 = 001 27:25 = 001 23:21 = 001 19:17 = 001
+			*((volatile u32*) PERSEUS2_IO_CONF8) = 0x2222ddd1; // 0x3333ddd1
+			
+			// D_SMC_PWR: TSPACT_9, D_SPI1_SEN1 SEN1
+			// bits 3:1 = 000
+			*((volatile u32*) PERSEUS2_IO_CONF9) = 0x15bbbdd2;
+
+			*((volatile u32*) PERSEUS2_IO_CONF4) = 0x11111111; // 27:25 for GPIO INT of FLIP STAT
+			*((volatile u32*) PERSEUS2_IO_CONF3) = 0x1d119911; // 27:25 FP_INT GPIO
+				
+			// D_SYREN_VOICE: VCLKRX, VDX, VDR, VFSRX
+		    	// bits 7:5 = 110: GPIO_22, GPIO_23, GPIN_3, GPIO_24
+		    	*((volatile u32*) PERSEUS2_IO_CONF2) = 0x111111D0;		    	
+		
+#endif													
+		break;
+		
+		default:
+		break;		
+	}
+	return 0;	
+}
+
+static void modem_bypass(int on_off)
+{
+	switch(on_off)
+	{
+		case 0: // EAC support
+    	*((volatile __u32 *) PERSEUS2_IO_CONF2) &= 0xFFFFFF1F;
+
+
+	// D_CRESET: GPIO36 used for headset detection
+			// INTERNAL_EAC_BT_AUSPI_SOURC: Pins BT AuSPI : SCLK, SDI, FSYNC
+			// SPI used for EAC_BT_SPI bits 3:2 = 00
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFF3;
+			
+			// INTERNAL_GSM_VOICE_SOURCE: Internal EAC Modem AuSPI
+			// bits 1:0 = 01
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFFC;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000001;
+		break;
+		
+		case 1: // on not-eac
+			// system setup to connect the modem directly to SYREN VSP
+			// and the EAC isn't used when calling
+			// D_SYREN_VOICE: VCLKRX, VDX, VDR, VFSRX
+			// D_SYREN_VOICE 7:5 = 001
+		    	*((volatile __u32 *) PERSEUS2_IO_CONF2) &= 0xFFFFFF0F;
+		    	*((volatile __u32 *) PERSEUS2_IO_CONF2) |= 0x00000030;
+			// INTERNAL_EAC_BT_AUSPI_SOURC: Pins BT AuSPI : SCLK, SDI, FSYNC
+			// SPI used for EAC_BT_SPI bits 3:2 = 00
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFF3;
+			
+			// INTERNAL_GSM_VOICE_SOURCE: Internal EAC Modem AuSPI
+			// bits 1:0 = 00
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFFC;
+		break;
+		
+		case 2: // bt enable
+			*((volatile u32*) PERSEUS2_IO_CONF2) &= 0xFFFFFF0F;
+		        *((volatile u32*) PERSEUS2_IO_CONF2) |= 0x000000D0;
+
+		        *((volatile u32*) PERSEUS2_IO_CONF8) &= 0x0000FFFF; //0x2222ddd1; // 0x3333ddd1
+		        *((volatile u32*) PERSEUS2_IO_CONF8) |= 0x33330000; //0x2222ddd1; // 0x3333ddd1	
+
+			// bits 3:2 = 01: Pins MPU_SPI: MPU_SCLK, MPU_SDI,
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFF3;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000004;
+
+		        // INTERNAL_GSM_VOICE_SOURCE: Internal EAC Modem AuSPI
+			// bits 1:0 = 01: Internal EAC modem AuSPI
+			*((volatile __u32 *) PERSEUS2_MODE_1) &= 0xFFFFFFFC;
+			*((volatile __u32 *) PERSEUS2_MODE_1) |= 0x00000001;
+		break;
+				
+		default:
+		break;		
+	}
+	return;	
+}
+
+static int audio_dev_id, mixer_dev_id;
+
+#define EAC_BPMCCFR_DEFAULT_SLAVE_NOCOMP_13BITS 0x00EC
+static int __init omap730_syren_init(void)
+{
+	u16 temp;
+	FN_IN;
+
+	eac_dump();
+
+	/*
+	 * Pins multiplexing
+	 */
+
+	//modem_bypass(0);
+	/*
+	 * UPLD Clocks
+	 */
+
+	*((volatile __u16 *) SOFT_REQ_REG) |= SOFT_REQ_REG_EAC12M_DPLL_REQ;
+	*((volatile __u16 *) PCC_PERIPH_CLOCK_SOURCE_SEL) &= ~PCC_PERIPH_SOURCE_EAC_CLK_SOURCE;
+	*((volatile __u16 *) CAM_CLK_CTRL) |= CAM_CLK_CTRL_SYSTEM_CLK_EN;
+
+	/*
+	 * GPIO pins setup to detect headset
+	 */
+	// TODO: GPIO36 for headset detection
+
+
+	/*
+	 * EAC setup
+	 */
+
+	// Audio Global Control Register 2
+	temp = omap730_eac_read((u16 *) EAC_AGCTR);
+	// EAC in powerdown mode
+	temp |= EAC_AGCTR_EACPWD;
+	// Audio processing disabled
+	temp &= ~EAC_AGCTR_AUDEN;
+	omap730_eac_write((u16 *) EAC_AGCTR, temp);
+
+	// Audio Global Configuration Register
+	temp = omap730_eac_read((u16 *) EAC_AGCFR) & EAC_AGCFR_RESERVED;
+	// stereo, 16 bit audio file
+	temp |= EAC_AGCFR_B8_16 | EAC_AGCFR_MN_ST;
+	// clock setting
+	temp |= EAC_AGCFR_AUD_CKSRC_12MHZ;
+	omap730_eac_write((u16 *) EAC_AGCFR, temp);
+
+	// EAC rev2 Intermediate sample frequency for DMA read and write operations
+	omap730_set_samplerate(AUDIO_RATE_DEFAULT);
+
+	// set clock on
+	omap730_setclock(1);
+
+	// Audio Mixer Switchs Configuration Register
+	omap730_eac_write((u16 *) EAC_AMSCFR, 0xFEF); //0xFEF); //k5 = 0 becoz c-codec no input EAC_AMSCFR_DEFAULT_SWITCHES);
+	//omap730_eac_write((u16 *) EAC_AMSCFR, 0x0A00);
+
+	// Set default volume
+	// Default DMA volume
+	omap730_eac_write((u16 *) EAC_AMVCTR, (DMA_DEFAULT_VOLUME << EAC_AMVCTR_RD_DMA_OFFSET) | (DMA_DEFAULT_VOLUME << EAC_AMVCTR_WR_DMA_OFFSET));
+	// Line (GSM) & Mic input volume control
+    //    eac_local.line = eac_local.mic = DEFAULT_INPUT_VOLUME;
+		eac_local.line = eac_local.mic = DEFAULT_VOLUME;
+
+	// MPU volume control
+        eac_local.volume = DEFAULT_VOLUME;
+        eac_update();
+	// No sidetone
+	temp = omap730_eac_read((u16 *) EAC_ASTCTR);
+	temp &= ~EAC_ASTCTR_ATTEN;
+	omap730_eac_write((u16 *) EAC_ASTCTR, temp);
+
+	// Audio processing enable
+	temp = omap730_eac_read((u16 *) EAC_AGCTR);
+	temp |= EAC_AGCTR_AUDEN;
+	omap730_eac_write((u16 *) EAC_AGCTR, temp);
+
+	/*
+	 * Codec port setup
+	 */
+
+	// CODEC Port Interface Control and Status Register
+	temp = omap730_eac_read((u16 *) EAC_CPTCTL) & EAC_CPTCTL_RESERVED;
+	// CODEC RESET release , clear RECEIVE DATA REGISTER FULL and TRANSMIT DATA REGISTER EMPTY
+	temp |= EAC_CPTCTL_CRST | EAC_CPTCTL_TXE | EAC_CPTCTL_RXF;
+	// C_PORT ENABLE Disabled to configure some registers
+	temp &= ~EAC_CPTCTL_CPEN;
+	omap730_eac_write((u16 *) EAC_CPTCTL, temp);
+
+	// Codec Port Configuration Register 1
+	// Codec-Port interface mode: I2S mode, Number of time slots per audio frame: 2 time slots per frame
+	omap730_eac_write((u16 *) EAC_CPCFR1, EAC_CPCFR1_MODE_I2S);
+
+	// CODEC PORT CONFIGURATION REGISTER 2
+	omap730_eac_write((u16 *) EAC_CPCFR2, EAC_CPCFR2_I2S_20BITS);
+
+	// CODEC PORT INTERFACE CONFIGURATION REGISTER 3
+	omap730_eac_write((u16 *) EAC_CPCFR3, EAC_CPCFR3_I2S_INPUT);
+
+	// CODECPORT INTERFACE CONFIGURATION REGISTER 4
+	// DIVB Calc: (12000000/(2*16*44100))-1=7
+	omap730_eac_write((u16 *) EAC_CPCFR4, EAC_CPCFR4_I2S_DIV7);
+
+	// CODEC Port Interface Control and Status Register
+	temp = omap730_eac_read((u16 *) EAC_CPTCTL) & EAC_CPTCTL_RESERVED;
+	// C_PORT ENABLE Enabled
+	temp |= EAC_CPTCTL_CPEN;
+	omap730_eac_write((u16 *) EAC_CPTCTL, temp);
+
+	/*
+	 * Modem port setup
+	 */
+
+	// Modem Port Control Register
+	omap730_eac_write((u16 *) EAC_MPCTR, EAC_MPCTR_DISABLEALL);
+
+	// Modem Port Main channel Configuration Register
+	omap730_eac_write((u16 *) EAC_MPMCCFR, EAC_MPMCCFR_DEFAULT_MASTER_NOCOMP_16BITS);
+
+	// Modem Port Control Register
+	temp = omap730_eac_read((u16 *) EAC_MPCTR);
+	temp |= EAC_MPCTR_PRE_MC_16 | EAC_MPCTR_MC_EN;	// Prescaler and enable
+	omap730_eac_write((u16 *) EAC_MPCTR, temp);
+	temp |= EAC_MPCTR_CKEN;				// Clocks running
+	omap730_eac_write((u16 *) EAC_MPCTR, temp);
+
+	/*
+	 * Bluetooth port setup
+	 */
+
+	// Bluetooth Port Control Register
+	omap730_eac_write((u16 *) EAC_BPCTR, EAC_BPCTR_DISABLEALL);
+
+	// Bluetooth Port Main channel Configuration Register
+	omap730_eac_write((u16 *) EAC_BPMCCFR, EAC_BPMCCFR_DEFAULT_SLAVE_NOCOMP_13BITS);
+
+	// Modem Port Control Register
+	temp = omap730_eac_read((u16 *) EAC_BPCTR);
+	temp |= EAC_BPCTR_PRE_MC_16 | EAC_BPCTR_MC_EN;	// Prescaler and enable
+	omap730_eac_write((u16 *) EAC_BPCTR, temp);
+	temp |= EAC_BPCTR_CKEN;				// Clocks running
+	omap730_eac_write((u16 *) EAC_BPCTR, temp);
+
+
+	/*
+	 * Driver init
+	 */
+
+	/* register devices */
+	audio_dev_id = register_sound_dsp(&omap730_audio_fops, -1);
+	mixer_dev_id = register_sound_mixer(&omap730_mixer_fops, -1);
+
+#ifdef CONFIG_CEE  /* MVL-CCE */
+        audio_ldm_device_register();
+        audio_ldm_driver_register();
+#endif /* MVL-CCE */
+
+	printk(KERN_INFO "OMAP730 audio support initialized\n");
+	
+	//GSM_SetupAudio(0, 0x03, 0, 6);
+	//GTI_Output_CTRL(768);
+	//GSM_SetupAudio(1, 0x03, 0, 6);
+	eac_dump();
+	//GTI_Output_CTRL();
+
+#ifdef EAC_PROC_SUPPORT
+		if(retval = create_eac_proc())
+			return retval;
+#endif
+	FN_OUT(0);
+	return 0;
+}
+
+static void __exit omap730_syren_exit(void)
+{
+
+#ifdef CONFIG_CEE  /* MVL-CCE */
+        audio_ldm_device_unregister();
+        audio_ldm_driver_unregister();
+#endif /* MVL-CCE */
+	//free_irq(INT_SYREN, NULL);
+	//free_irq(INT_EARPHONE_JACK, NULL);
+	//free_irq(INT_HOOK_DETECT,NULL);
+	
+	unregister_sound_dsp(audio_dev_id);
+	unregister_sound_mixer(mixer_dev_id);
+}
+
+module_init(omap730_syren_init);
+module_exit(omap730_syren_exit);
+
+MODULE_AUTHOR("Jean Pihet");
+MODULE_DESCRIPTION("Glue audio driver for the TI OMAP730 & TI TWL3016 (Syren) CODEC");
+MODULE_LICENSE("GPL");
+
+EXPORT_NO_SYMBOLS;
-- 
1.5.6

